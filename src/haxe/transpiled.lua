-- Generated by Haxe 4.3.3
local _hx_hidden = {
   __id__ = true,
   hx__closures = true,
   super = true,
   prototype = true,
   __fields__ = true,
   __ifields__ = true,
   __class__ = true,
   __properties__ = true,
   __fields__ = true,
   __name__ = true,
}

_hx_array_mt = {
   __newindex = function(t, k, v)
      local len = t.length
      t.length = k >= len and (k + 1) or len
      rawset(t, k, v)
   end,
}

function _hx_is_array(o)
   return type(o) == "table" and o.__enum__ == nil and getmetatable(o) == _hx_array_mt
end

function _hx_tab_array(tab, length)
   tab.length = length
   return setmetatable(tab, _hx_array_mt)
end

function _hx_print_class(obj, depth)
   local first = true
   local result = ""
   for k, v in pairs(obj) do
      if _hx_hidden[k] == nil then
         if first then
            first = false
         else
            result = result .. ", "
         end
         if _hx_hidden[k] == nil then
            result = result .. k .. ":" .. _hx_tostring(v, depth + 1)
         end
      end
   end
   return "{ " .. result .. " }"
end

function _hx_print_enum(o, depth)
   if o.length == 2 then
      return o[0]
   else
      local str = o[0] .. "("
      for i = 2, (o.length - 1) do
         if i ~= 2 then
            str = str .. "," .. _hx_tostring(o[i], depth + 1)
         else
            str = str .. _hx_tostring(o[i], depth + 1)
         end
      end
      return str .. ")"
   end
end

function _hx_tostring(obj, depth)
   if depth == nil then
      depth = 0
   elseif depth > 5 then
      return "<...>"
   end

   local tstr = _G.type(obj)
   if tstr == "string" then
      return obj
   elseif tstr == "nil" then
      return "null"
   elseif tstr == "number" then
      if obj == _G.math.POSITIVE_INFINITY then
         return "Infinity"
      elseif obj == _G.math.NEGATIVE_INFINITY then
         return "-Infinity"
      elseif obj == 0 then
         return "0"
      elseif obj ~= obj then
         return "NaN"
      else
         return _G.tostring(obj)
      end
   elseif tstr == "boolean" then
      return _G.tostring(obj)
   elseif tstr == "userdata" then
      local mt = _G.getmetatable(obj)
      if mt ~= nil and mt.__tostring ~= nil then
         return _G.tostring(obj)
      else
         return "<userdata>"
      end
   elseif tstr == "function" then
      return "<function>"
   elseif tstr == "thread" then
      return "<thread>"
   elseif tstr == "table" then
      if obj.__enum__ ~= nil then
         return _hx_print_enum(obj, depth)
      elseif obj.toString ~= nil and not _hx_is_array(obj) then
         return obj:toString()
      elseif _hx_is_array(obj) then
         if obj.length > 5 then
            return "[...]"
         else
            local str = ""
            for i = 0, (obj.length - 1) do
               if i == 0 then
                  str = str .. _hx_tostring(obj[i], depth + 1)
               else
                  str = str .. "," .. _hx_tostring(obj[i], depth + 1)
               end
            end
            return "[" .. str .. "]"
         end
      elseif obj.__class__ ~= nil then
         return _hx_print_class(obj, depth)
      else
         local buffer = {}
         local ref = obj
         if obj.__fields__ ~= nil then
            ref = obj.__fields__
         end
         for k, v in pairs(ref) do
            if _hx_hidden[k] == nil then
               _G.table.insert(
                  buffer,
                  _hx_tostring(k, depth + 1) .. " : " .. _hx_tostring(obj[k], depth + 1)
               )
            end
         end

         return "{ " .. table.concat(buffer, ", ") .. " }"
      end
   else
      _G.error("Unknown Lua type", 0)
      return ""
   end
end

local function _hx_obj_newindex(t, k, v)
   t.__fields__[k] = true
   rawset(t, k, v)
end

local _hx_obj_mt = { __newindex = _hx_obj_newindex, __tostring = _hx_tostring }

local function _hx_a(...)
   local __fields__ = {}
   local ret = { __fields__ = __fields__ }
   local max = select("#", ...)
   local tab = { ... }
   local cur = 1
   while cur < max do
      local v = tab[cur]
      __fields__[v] = true
      ret[v] = tab[cur + 1]
      cur = cur + 2
   end
   return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
   return setmetatable({ __fields__ = {} }, _hx_obj_mt)
end

local function _hx_o(obj)
   return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
   return setmetatable(
      { __fields__ = {} },
      { __newindex = _hx_obj_newindex, __index = prototype, __tostring = _hx_tostring }
   )
end

function _hx_field_arr(obj)
   local res = {}
   local idx = 0
   if obj.__fields__ ~= nil then
      obj = obj.__fields__
   end
   for k, v in pairs(obj) do
      if _hx_hidden[k] == nil then
         res[idx] = k
         idx = idx + 1
      end
   end
   return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e()
local Dynamic = _hx_e()
local Float = _hx_e()
local Bool = _hx_e()
local Class = _hx_e()
local Enum = _hx_e()

local Array = _hx_e()
__echoes_ComponentStorage = _hx_e()
__echoes_System = _hx_e()
__echoes_SystemList = _hx_e()
__echoes_utils_Clock = _hx_e()
local Sys = _hx_e()
__lua_lib_luv_Misc = _G.require("luv")
__echoes_Echoes = _hx_e()
local ComponentStorage_EchoesBenchmarkOptional = _hx_e()
local ComponentStorage_EchoesBenchmarkPadding1 = _hx_e()
local ComponentStorage_EchoesBenchmarkPadding2 = _hx_e()
local ComponentStorage_EchoesBenchmarkPadding3 = _hx_e()
local ComponentStorage_EchoesBenchmarkPosition = _hx_e()
local ComponentStorage_EchoesBenchmarkVelocity = _hx_e()
__lua_lib_luautf8_Utf8 = _G.require("lua-utf8")
local Position = _hx_e()
local Velocity = _hx_e()
local MovementSystem = _hx_e()
HaxeBenchmark = _hx_e()
AddEmptyEntity = _hx_e()
AddEntities = _hx_e()
local EntityFactory = _hx_e()
RemoveEntities = _hx_e()
GetComponent = _hx_e()
GetComponents = _hx_e()
AddComponent = _hx_e()
AddComponents = _hx_e()
RemoveComponent = _hx_e()
RemoveComponents = _hx_e()
SystemUpdate = _hx_e()
local Lambda = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local Type = _hx_e()
__echoes_ViewBase = _hx_e()
local ViewOf_Position_Velocity_92d16 = _hx_e()
__echoes__ComponentStorage_DynamicComponentStorage_Impl_ = _hx_e()
__echoes__ComponentStorage_EntityComponents_Impl_ = _hx_e()
__echoes__Entity_Entity_Impl_ = _hx_e()
__echoes__Entity_Entity_Fields_ = _hx_e()
__echoes__System_ChildSystem = _hx_e()
__echoes_View = _hx_e()
__echoes_utils__ComponentTypes_ComponentTypes_Impl_ = _hx_e()
__echoes_utils__ReadOnlyData_ReadOnlyList_Impl_ = _hx_e()
__echoes_utils__Signal_Signal_Impl_ = _hx_e()
__haxe_IMap = _hx_e()
__haxe_EntryPoint = _hx_e()
__haxe_Exception = _hx_e()
__haxe_MainEvent = _hx_e()
__haxe_MainLoop = _hx_e()
__haxe_NativeStackTrace = _hx_e()
__haxe_Timer = _hx_e()
__haxe_ValueException = _hx_e()
__haxe_ds_List = _hx_e()
__haxe_ds__List_ListNode = _hx_e()
__haxe_ds__List_ListIterator = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_exceptions_PosException = _hx_e()
__haxe_exceptions_NotImplementedException = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__haxe_macro_Error = _hx_e()
__lua_Boot = _hx_e()
__lua_UserData = _hx_e()
__lua_Thread = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {}
local _hx_pcall_break = {}

Array.new = function()
   local self = _hx_new(Array.prototype)
   Array.super(self)
   return self
end
Array.super = function(self)
   _hx_tab_array(self, 0)
end
Array.__name__ = "Array"
Array.prototype = _hx_e()
Array.prototype.concat = function(self, a)
   local _g = _hx_tab_array({}, 0)
   local _g1 = 0
   while _g1 < self.length do
      _hx_do_first_1 = false

      local i = self[_g1]
      _g1 = _g1 + 1
      _g:push(i)
   end
   local _g1 = 0
   while _g1 < a.length do
      _hx_do_first_1 = false

      local i = a[_g1]
      _g1 = _g1 + 1
      _g:push(i)
   end
   do
      return _g
   end
end
Array.prototype.join = function(self, sep)
   local tbl = {}
   local _g_current = 0
   while _g_current < self.length do
      _hx_do_first_1 = false

      _g_current = _g_current + 1
      _G.table.insert(tbl, Std.string(self[_g_current - 1]))
   end
   do
      return _G.table.concat(tbl, sep)
   end
end
Array.prototype.pop = function(self)
   if self.length == 0 then
      do
         return nil
      end
   end
   local ret = self[self.length - 1]
   self[self.length - 1] = nil
   self.length = self.length - 1
   do
      return ret
   end
end
Array.prototype.push = function(self, x)
   self[self.length] = x
   do
      return self.length
   end
end
Array.prototype.reverse = function(self)
   local tmp
   local i = 0
   while i < Std.int(self.length / 2) do
      _hx_do_first_1 = false

      tmp = self[i]
      self[i] = self[(self.length - i) - 1]
      self[(self.length - i) - 1] = tmp
      i = i + 1
   end
end
Array.prototype.shift = function(self)
   if self.length == 0 then
      do
         return nil
      end
   end
   local ret = self[0]
   if self.length == 1 then
      self[0] = nil
   else
      if self.length > 1 then
         self[0] = self[1]
         _G.table.remove(self, 1)
      end
   end
   local tmp = self
   tmp.length = tmp.length - 1
   do
      return ret
   end
end
Array.prototype.slice = function(self, pos, _end)
   if (_end == nil) or (_end > self.length) then
      _end = self.length
   else
      if _end < 0 then
         _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length)
      end
   end
   if pos < 0 then
      pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length)
   end
   if (pos > _end) or (pos > self.length) then
      do
         return _hx_tab_array({}, 0)
      end
   end
   local ret = _hx_tab_array({}, 0)
   local _g = pos
   local _g1 = _end
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      ret:push(self[_g - 1])
   end
   do
      return ret
   end
end
Array.prototype.sort = function(self, f)
   local i = 0
   local l = self.length
   while i < l do
      _hx_do_first_1 = false

      local swap = false
      local j = 0
      local max = (l - i) - 1
      while j < max do
         _hx_do_first_2 = false

         if f(self[j], self[j + 1]) > 0 then
            local tmp = self[j + 1]
            self[j + 1] = self[j]
            self[j] = tmp
            swap = true
         end
         j = j + 1
      end
      if not swap then
         break
      end
      i = i + 1
   end
end
Array.prototype.splice = function(self, pos, len)
   if (len < 0) or (pos > self.length) then
      do
         return _hx_tab_array({}, 0)
      end
   else
      if pos < 0 then
         pos = self.length - (_G.math.fmod(-pos, self.length))
      end
   end
   len = Math.min(len, self.length - pos)
   local ret = _hx_tab_array({}, 0)
   local _g = pos
   local _g1 = pos + len
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      local i = _g - 1
      ret:push(self[i])
      self[i] = self[i + len]
   end
   local _g = pos + len
   local _g1 = self.length
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      local i = _g - 1
      self[i] = self[i + len]
   end
   self.length = self.length - len
   do
      return ret
   end
end
Array.prototype.toString = function(self)
   local tbl = {}
   _G.table.insert(tbl, "[")
   _G.table.insert(tbl, self:join(","))
   _G.table.insert(tbl, "]")
   do
      return _G.table.concat(tbl, "")
   end
end
Array.prototype.unshift = function(self, x)
   local len = self.length
   local _g = 0
   while _g < len do
      _hx_do_first_1 = false

      _g = _g + 1
      local i = _g - 1
      self[len - i] = self[(len - i) - 1]
   end
   self[0] = x
end
Array.prototype.insert = function(self, pos, x)
   if pos > self.length then
      pos = self.length
   end
   if pos < 0 then
      pos = self.length + pos
      if pos < 0 then
         pos = 0
      end
   end
   local cur_len = self.length
   while cur_len > pos do
      _hx_do_first_1 = false

      self[cur_len] = self[cur_len - 1]
      cur_len = cur_len - 1
   end
   self[pos] = x
end
Array.prototype.remove = function(self, x)
   local _g = 0
   local _g1 = self.length
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      local i = _g - 1
      if self[i] == x then
         local _g = i
         local _g1 = self.length - 1
         while _g < _g1 do
            _hx_do_first_2 = false

            _g = _g + 1
            local j = _g - 1
            self[j] = self[j + 1]
         end
         self[self.length - 1] = nil
         self.length = self.length - 1
         do
            return true
         end
      end
   end
   do
      return false
   end
end
Array.prototype.contains = function(self, x)
   local _g = 0
   local _g1 = self.length
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      if self[_g - 1] == x then
         do
            return true
         end
      end
   end
   do
      return false
   end
end
Array.prototype.indexOf = function(self, x, fromIndex)
   local _end = self.length
   if fromIndex == nil then
      fromIndex = 0
   else
      if fromIndex < 0 then
         fromIndex = self.length + fromIndex
         if fromIndex < 0 then
            fromIndex = 0
         end
      end
   end
   local _g = fromIndex
   while _g < _end do
      _hx_do_first_1 = false

      _g = _g + 1
      local i = _g - 1
      if x == self[i] then
         do
            return i
         end
      end
   end
   do
      return -1
   end
end
Array.prototype.lastIndexOf = function(self, x, fromIndex)
   if (fromIndex == nil) or (fromIndex >= self.length) then
      fromIndex = self.length - 1
   else
      if fromIndex < 0 then
         fromIndex = self.length + fromIndex
         if fromIndex < 0 then
            do
               return -1
            end
         end
      end
   end
   local i = fromIndex
   while i >= 0 do
      _hx_do_first_1 = false

      if self[i] == x then
         do
            return i
         end
      else
         i = i - 1
      end
   end
   do
      return -1
   end
end
Array.prototype.copy = function(self)
   local _g = _hx_tab_array({}, 0)
   local _g1 = 0
   while _g1 < self.length do
      _hx_do_first_1 = false

      local i = self[_g1]
      _g1 = _g1 + 1
      _g:push(i)
   end
   do
      return _g
   end
end
Array.prototype.map = function(self, f)
   local _g = _hx_tab_array({}, 0)
   local _g1 = 0
   while _g1 < self.length do
      _hx_do_first_1 = false

      local i = self[_g1]
      _g1 = _g1 + 1
      _g:push(f(i))
   end
   do
      return _g
   end
end
Array.prototype.filter = function(self, f)
   local _g = _hx_tab_array({}, 0)
   local _g1 = 0
   while _g1 < self.length do
      _hx_do_first_1 = false

      local i = self[_g1]
      _g1 = _g1 + 1
      if f(i) then
         _g:push(i)
      end
   end
   do
      return _g
   end
end
Array.prototype.iterator = function(self)
   do
      return __haxe_iterators_ArrayIterator.new(self)
   end
end
Array.prototype.keyValueIterator = function(self)
   do
      return __haxe_iterators_ArrayKeyValueIterator.new(self)
   end
end
Array.prototype.resize = function(self, len)
   if self.length < len then
      self.length = len
   else
      if self.length > len then
         local _g = len
         local _g1 = self.length
         while _g < _g1 do
            _hx_do_first_1 = false

            _g = _g + 1
            self[_g - 1] = nil
         end
         self.length = len
      end
   end
end

Array.prototype.__class__ = Array

__echoes_ComponentStorage.new = function(componentType)
   local self = _hx_new(__echoes_ComponentStorage.prototype)
   __echoes_ComponentStorage.super(self, componentType)
   return self
end
__echoes_ComponentStorage.super = function(self, componentType)
   self.storage = _hx_tab_array({}, 0)
   self._relatedViews = _hx_tab_array({}, 0)
   self.ongoingRemovals = _hx_tab_array({}, 0)
   self.componentType = componentType
   __echoes_Echoes.componentStorage:push(self)
end
__echoes_ComponentStorage.__name__ = "echoes.ComponentStorage"
__echoes_ComponentStorage.prototype = _hx_e()
__echoes_ComponentStorage.prototype.get_name = function(self)
   do
      return Std.string(Std.string("ComponentStorage<") .. Std.string(self.componentType))
         .. Std.string(">")
   end
end
__echoes_ComponentStorage.prototype.get_relatedViews = function(self)
   do
      return self._relatedViews
   end
end
__echoes_ComponentStorage.prototype.add = function(self, entity, component)
   if component == nil then
      self:remove(entity)
      do
         return
      end
   end
   if self.storage[entity] == component then
      do
         return
      end
   end
   if self.ongoingRemovals:contains(entity) then
      _G.error(
         __haxe_Exception.thrown(
            Std.string(
               Std.string(
                  Std.string(Std.string("Attempted to add ") .. Std.string(self.componentType))
                     .. Std.string(" to entity ")
               ) .. Std.string(entity)
            ) .. Std.string(" during a @:remove listener for that component.")
         ),
         0
      )
   end
   self.storage[entity] = component
   local components = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
   if components == nil then
      components = Array.new()
      __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = components
   end
   local storage = self
   if not components:contains(storage) then
      components:push(storage)
   end
   if __echoes_Echoes.activeEntityIndices[entity] ~= nil then
      local _g = 0
      local _g1 = self._relatedViews
      while _g < _g1.length do
         _hx_do_first_1 = false

         local view = _g1[_g]
         _g = _g + 1
         if view:isMatched(entity) then
            if not view._entities:contains(entity) then
               view._entities:push(entity)
            end
            view:dispatchAddedCallback(entity)
         end
         if self.storage[entity] == nil then
            do
               return
            end
         end
      end
   end
end
__echoes_ComponentStorage.prototype.clear = function(self)
   self.storage:resize(0)
   self.ongoingRemovals:resize(0)
end
__echoes_ComponentStorage.prototype.exists = function(self, entity)
   do
      return self.storage[entity] ~= nil
   end
end
__echoes_ComponentStorage.prototype.get = function(self, entity)
   do
      return self.storage[entity]
   end
end
__echoes_ComponentStorage.prototype.remove = function(self, entity)
   local removedComponent = self.storage[entity]
   self.storage[entity] = nil
   if removedComponent ~= nil then
      local this1 = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
      local index = this1:lastIndexOf(self)
      if index >= 0 then
         this1[index] = this1[this1.length - 1]
         this1:pop()
      end
      if __echoes_Echoes.activeEntityIndices[entity] ~= nil then
         self.ongoingRemovals:push(entity)
         local exception = nil
         local _g = 0
         local _g1 = self._relatedViews
         while _g < _g1.length do
            _hx_do_first_1 = false

            local view = _g1[_g]
            _g = _g + 1
            local _hx_status, _hx_result = pcall(function()
               local index = view._entities:lastIndexOf(entity)
               if index >= 0 then
                  view._entities[index] = view._entities[view._entities.length - 1]
                  view._entities:pop()
                  view:dispatchRemovedCallback(entity, self, removedComponent)
               end
               return _hx_pcall_default
            end)
            if not _hx_status and _hx_result == "_hx_pcall_break" then
               break
            elseif not _hx_status then
               local _g = _hx_result
               exception = __haxe_Exception.caught(_g)
            elseif _hx_result ~= _hx_pcall_default then
               return _hx_result
            end
         end
         self.ongoingRemovals:remove(entity)
         if exception ~= nil then
            _G.error(__haxe_Exception.thrown(exception), 0)
         end
      end
   end
end
__echoes_ComponentStorage.prototype.replace = function(self, entity, component)
   if self.storage[entity] ~= component then
      self:remove(entity)
      self:add(entity, component)
   end
end
__echoes_ComponentStorage.prototype.toString = function(self)
   do
      return Std.string(Std.string("ComponentStorage<") .. Std.string(self.componentType))
         .. Std.string(">")
   end
end

__echoes_ComponentStorage.prototype.__class__ = __echoes_ComponentStorage

__echoes_System.new = function(priority)
   local self = _hx_new(__echoes_System.prototype)
   __echoes_System.super(self, priority)
   return self
end
__echoes_System.super = function(self, priority)
   self.onDeactivate = Array.new()
   self.onActivate = Array.new()
   self.active = false
   self.__dt__ = 0
   self.__children__ = _hx_tab_array({}, 0)
   self.priority = (function()
      local _hx_1
      if priority ~= nil then
         _hx_1 = priority
      else
         _hx_1 = self:__getDefaultPriority__()
      end
      return _hx_1
   end)()
   if self.parent ~= nil then
      self.parent:__recalculateOrder__(self)
   end
end
__echoes_System.__name__ = "echoes.System"
__echoes_System.prototype = _hx_e()
__echoes_System.prototype.set_priority = function(self, value)
   self.priority = value
   if self.parent ~= nil then
      self.parent:__recalculateOrder__(self)
   end
   do
      return self.priority
   end
end
__echoes_System.prototype.__activate__ = function(self)
   if not self.active then
      self.active = true
      self.__dt__ = 0
      local _g = 0
      local _g1 = self.onActivate
      while _g < _g1.length do
         _hx_do_first_1 = false

         local listener = _g1[_g]
         _g = _g + 1
         listener()
      end
   end
end
__echoes_System.prototype.__addListenersWithPriority__ = function(
   self,
   priority,
   runUpdateListeners
)
   self.__children__:push(__echoes__System_ChildSystem.new(self, priority, runUpdateListeners))
end
__echoes_System.prototype.__deactivate__ = function(self)
   if self.active then
      self.active = false
      local _g = 0
      local _g1 = self.onDeactivate
      while _g < _g1.length do
         _hx_do_first_1 = false

         local listener = _g1[_g]
         _g = _g + 1
         listener()
      end
   end
end
__echoes_System.prototype.__getDefaultPriority__ = function(self)
   do
      return 0
   end
end
__echoes_System.prototype.__update__ = function(self, dt)
   self.__dt__ = dt
end
__echoes_System.prototype.activate = function(self)
   __echoes_Echoes.activeSystems:add(self)
end
__echoes_System.prototype.deactivate = function(self)
   self.parent:remove(self)
end
__echoes_System.prototype.find = function(self, systemType)
   if __lua_Boot.__instanceof(self, systemType) then
      do
         return self
      end
   else
      do
         return nil
      end
   end
end
__echoes_System.prototype.getStatistics = function(self)
   do
      return _hx_o({ __fields__ = { name = true }, name = Std.string(self) })
   end
end
__echoes_System.prototype.toString = function(self)
   local c = Type.getClass(self)
   do
      return c.__name__
   end
end

__echoes_System.prototype.__class__ = __echoes_System

__echoes_SystemList.new = function(name, clock, priority)
   local self = _hx_new(__echoes_SystemList.prototype)
   __echoes_SystemList.super(self, name, clock, priority)
   return self
end
__echoes_SystemList.super = function(self, name, clock, priority)
   if priority == nil then
      priority = 0
   end
   if name == nil then
      name = "SystemList"
   end
   self.systems = _hx_tab_array({}, 0)
   __echoes_System.super(self, priority)
   self.name = name
   self.clock = (function()
      local _hx_1
      if clock ~= nil then
         _hx_1 = clock
      else
         _hx_1 = __echoes_utils_Clock.new()
      end
      return _hx_1
   end)()
end
__echoes_SystemList.__name__ = "echoes.SystemList"
__echoes_SystemList.prototype = _hx_e()
__echoes_SystemList.prototype.get_length = function(self)
   do
      return self.systems.length
   end
end
__echoes_SystemList.prototype.get_paused = function(self)
   do
      return self.clock.paused
   end
end
__echoes_SystemList.prototype.set_paused = function(self, value)
   self.clock.paused = value
   do
      return self.clock.paused
   end
end
__echoes_SystemList.prototype.__activate__ = function(self)
   if not self.active then
      local _g = 0
      local _g1 = self.systems
      while _g < _g1.length do
         _hx_do_first_1 = false

         local system = _g1[_g]
         _g = _g + 1
         system:__activate__()
      end
      __echoes_System.prototype.__activate__(self)
   end
end
__echoes_SystemList.prototype.__deactivate__ = function(self)
   if self.active then
      local _g = 0
      local _g1 = self.systems
      while _g < _g1.length do
         _hx_do_first_1 = false

         local system = _g1[_g]
         _g = _g + 1
         system:__deactivate__()
      end
      __echoes_System.prototype.__deactivate__(self)
   end
end
__echoes_SystemList.prototype.__recalculateOrder__ = function(self, system)
   if self.systems:remove(system) then
      local index = Lambda.findIndex(self.systems, function(existingSystem)
         do
            return existingSystem.priority < system.priority
         end
      end)
      if index >= 0 then
         local _this = self.systems
         local pos = index
         if index > _this.length then
            pos = _this.length
         end
         if pos < 0 then
            pos = _this.length + pos
            if pos < 0 then
               pos = 0
            end
         end
         local cur_len = _this.length
         while cur_len > pos do
            _hx_do_first_1 = false

            _this[cur_len] = _this[cur_len - 1]
            cur_len = cur_len - 1
         end
         _this[pos] = system
      else
         self.systems:push(system)
      end
   end
end
__echoes_SystemList.prototype.__update__ = function(self, dt)
   self.__dt__ = dt
   self.clock:addTime(dt)
   local _g = self.clock
   while _g.time >= _g.minTickLength do
      _hx_do_first_1 = false

      local step = _g:next()
      local _g = 0
      local _g1 = self.systems
      while _g < _g1.length do
         _hx_do_first_2 = false

         local system = _g1[_g]
         _g = _g + 1
         system:__update__(step)
      end
   end
end
__echoes_SystemList.prototype.add = function(self, system)
   if system.parent ~= nil then
      if system.parent == self then
         do
            return self
         end
      end
      system.parent:remove(system)
   end
   local index = Lambda.findIndex(self.systems, function(existingSystem)
      do
         return existingSystem.priority < system.priority
      end
   end)
   if index >= 0 then
      local _this = self.systems
      local pos = index
      if index > _this.length then
         pos = _this.length
      end
      if pos < 0 then
         pos = _this.length + pos
         if pos < 0 then
            pos = 0
         end
      end
      local cur_len = _this.length
      while cur_len > pos do
         _hx_do_first_1 = false

         _this[cur_len] = _this[cur_len - 1]
         cur_len = cur_len - 1
      end
      _this[pos] = system
   else
      self.systems:push(system)
   end
   system.parent = self
   if self.active then
      system:__activate__()
   end
   local _g = 0
   local _g1 = system.__children__
   while _g < _g1.length do
      _hx_do_first_1 = false

      local child = _g1[_g]
      _g = _g + 1
      self:add(child)
   end
   do
      return self
   end
end
__echoes_SystemList.prototype.exists = function(self, system)
   local parent = system.parent
   while (parent ~= nil) and (parent ~= self) do
      _hx_do_first_1 = false

      parent = parent.parent
   end
   do
      return parent == self
   end
end
__echoes_SystemList.prototype.find = function(self, systemType)
   local _g = 0
   local _g1 = self.systems
   while _g < _g1.length do
      _hx_do_first_1 = false

      local child = _g1[_g]
      _g = _g + 1
      local result = child:find(systemType)
      if result ~= nil then
         do
            return result
         end
      end
   end
   do
      return nil
   end
end
__echoes_SystemList.prototype.getStatistics = function(self)
   local result = __echoes_System.prototype.getStatistics(self)
   local _g = _hx_tab_array({}, 0)
   local _g1 = 0
   local _g2 = self.systems
   while _g1 < _g2.length do
      _hx_do_first_1 = false

      local system = _g2[_g1]
      _g1 = _g1 + 1
      _g:push(system:getStatistics())
   end
   result.children = _g
   do
      return result
   end
end
__echoes_SystemList.prototype.iterator = function(self)
   do
      return __haxe_iterators_ArrayIterator.new(self.systems)
   end
end
__echoes_SystemList.prototype.keyValueIterator = function(self)
   do
      return __haxe_iterators_ArrayKeyValueIterator.new(self.systems)
   end
end
__echoes_SystemList.prototype.remove = function(self, system)
   if self.systems:remove(system) then
      system:__deactivate__()
      system.parent = nil
      if system.__children__ ~= nil then
         local _g = 0
         local _g1 = system.__children__
         while _g < _g1.length do
            _hx_do_first_1 = false

            local child = _g1[_g]
            _g = _g + 1
            self:remove(child)
         end
      end
   end
   do
      return self
   end
end
__echoes_SystemList.prototype.removeAll = function(self)
   local _g = 0
   local _g1 = self.systems
   while _g < _g1.length do
      _hx_do_first_1 = false

      local system = _g1[_g]
      _g = _g + 1
      system:__deactivate__()
      system.parent = nil
   end
   self.systems:resize(0)
   do
      return self
   end
end
__echoes_SystemList.prototype.toString = function(self)
   do
      return self.name
   end
end

__echoes_SystemList.prototype.__class__ = __echoes_SystemList
__echoes_SystemList.__super__ = __echoes_System
setmetatable(__echoes_SystemList.prototype, { __index = __echoes_System.prototype })

__echoes_utils_Clock.new = function()
   local self = _hx_new(__echoes_utils_Clock.prototype)
   __echoes_utils_Clock.super(self)
   return self
end
__echoes_utils_Clock.super = function(self)
   self.timeScale = 1
   self.time = 0
   self.tickCount = 0
   self.paused = false
   self.minTickLength = 1e-16
   self.maxTime = _G.math.huge
   self.maxTickLength = _G.math.huge
end
__echoes_utils_Clock.__name__ = "echoes.utils.Clock"
__echoes_utils_Clock.prototype = _hx_e()
__echoes_utils_Clock.prototype.addTime = function(self, time)
   if not self.paused then
      self.time = self.time + (time * self.timeScale)
      if self.time > self.maxTime then
         self.time = self.maxTime
      end
      self.tickCount = 0
   end
end
__echoes_utils_Clock.prototype.hasNext = function(self)
   do
      return self.time >= self.minTickLength
   end
end
__echoes_utils_Clock.prototype.next = function(self)
   local tick = (function()
      local _hx_1
      if self.time > self.maxTickLength then
         _hx_1 = self.maxTickLength
      else
         _hx_1 = self.time
      end
      return _hx_1
   end)()
   self.time = self.time - tick
   self.tickCount = self.tickCount + 1
   do
      return tick
   end
end
__echoes_utils_Clock.prototype.setFixedTickLength = function(self, fixedTickLength)
   self.maxTickLength = fixedTickLength
   self.minTickLength = self.maxTickLength
end

__echoes_utils_Clock.prototype.__class__ = __echoes_utils_Clock

Sys.new = {}
Sys.__name__ = "Sys"
Sys.time = function()
   local _hx_1_stamp_seconds, _hx_1_stamp_microseconds = __lua_lib_luv_Misc.gettimeofday()
   do
      return _hx_1_stamp_seconds + (_hx_1_stamp_microseconds / 1000000)
   end
end

__echoes_Echoes.new = {}
__echoes_Echoes.__name__ = "echoes.Echoes"
__echoes_Echoes.get_activeEntities = function()
   do
      return __echoes_Echoes._activeEntities
   end
end
__echoes_Echoes.get_activeViews = function()
   do
      return __echoes_Echoes._activeViews
   end
end
__echoes_Echoes.get_clock = function()
   do
      return __echoes_Echoes.activeSystems.clock
   end
end
__echoes_Echoes.init = function(fps)
   if fps == nil then
      fps = 60
   end
   __echoes_Echoes.lastUpdate = Sys.time()
   if __echoes_Echoes.updateTimer ~= nil then
      __echoes_Echoes.updateTimer:stop()
      __echoes_Echoes.updateTimer = nil
   end
   if fps > 0 then
      __echoes_Echoes.updateTimer = __haxe_Timer.new(Std.int(1000 / fps))
      __echoes_Echoes.updateTimer.run = _hx_funcToField(__echoes_Echoes.update)
   end
end
__echoes_Echoes.getStatistics = function()
   local tmp = __echoes__Entity_Entity_Impl_.idPool.length
   local tmp1 = __echoes_Echoes._activeEntities.length
   local _g = _hx_tab_array({}, 0)
   local _this = __echoes_Echoes.activeSystems.systems
   local system_current = 0
   while system_current < _this.length do
      _hx_do_first_1 = false

      system_current = system_current + 1
      _g:push(_this[system_current - 1]:getStatistics())
   end
   local _g1 = _hx_tab_array({}, 0)
   local _g2 = 0
   local _g3 = __echoes_Echoes._activeViews
   while _g2 < _g3.length do
      _hx_do_first_1 = false

      local view = _g3[_g2]
      _g2 = _g2 + 1
      _g1:push(
         _hx_o({
            __fields__ = { name = true, entities = true },
            name = Std.string(view),
            entities = view._entities.length,
         })
      )
   end
   do
      return _hx_o({
         __fields__ = { cachedEntities = true, entities = true, systems = true, views = true },
         cachedEntities = tmp,
         entities = tmp1,
         systems = _g,
         views = _g1,
      })
   end
end
__echoes_Echoes.update = function()
   local startTime = Sys.time()
   local dt = startTime - __echoes_Echoes.lastUpdate
   __echoes_Echoes.lastUpdate = startTime
   __echoes_Echoes.activeSystems:__update__(dt)
end
__echoes_Echoes.reset = function()
   __echoes_Echoes.activeEntityIndices:resize(0)
   __echoes_Echoes._activeEntities:resize(0)
   __echoes_Echoes.activeSystems:removeAll()
   local i = __echoes_Echoes._activeViews.length
   while true do
      _hx_do_first_1 = false

      i = i - 1
      if not (i >= 0) then
         break
      end
      __echoes_Echoes._activeViews[i]:reset()
   end
   local _g = 0
   local _g1 = __echoes_Echoes.componentStorage
   while _g < _g1.length do
      _hx_do_first_1 = false

      local storage = _g1[_g]
      _g = _g + 1
      storage.storage:resize(0)
      storage.ongoingRemovals:resize(0)
   end
   __echoes__ComponentStorage_EntityComponents_Impl_.components:resize(0)
   __echoes__Entity_Entity_Impl_.idPool:resize(0)
   __echoes__Entity_Entity_Impl_.nextId = 0
   __echoes_Echoes.init(0)
end

ComponentStorage_EchoesBenchmarkOptional.new = function()
   local self = _hx_new(ComponentStorage_EchoesBenchmarkOptional.prototype)
   ComponentStorage_EchoesBenchmarkOptional.super(self)
   return self
end
ComponentStorage_EchoesBenchmarkOptional.super = function(self)
   __echoes_ComponentStorage.super(self, "EchoesBenchmark.Optional")
end
ComponentStorage_EchoesBenchmarkOptional.__name__ = "ComponentStorage_EchoesBenchmarkOptional"
ComponentStorage_EchoesBenchmarkOptional.prototype = _hx_e()

ComponentStorage_EchoesBenchmarkOptional.prototype.__class__ =
   ComponentStorage_EchoesBenchmarkOptional
ComponentStorage_EchoesBenchmarkOptional.__super__ = __echoes_ComponentStorage
setmetatable(
   ComponentStorage_EchoesBenchmarkOptional.prototype,
   { __index = __echoes_ComponentStorage.prototype }
)

ComponentStorage_EchoesBenchmarkPadding1.new = function()
   local self = _hx_new(ComponentStorage_EchoesBenchmarkPadding1.prototype)
   ComponentStorage_EchoesBenchmarkPadding1.super(self)
   return self
end
ComponentStorage_EchoesBenchmarkPadding1.super = function(self)
   __echoes_ComponentStorage.super(self, "EchoesBenchmark.Padding1")
end
ComponentStorage_EchoesBenchmarkPadding1.__name__ = "ComponentStorage_EchoesBenchmarkPadding1"
ComponentStorage_EchoesBenchmarkPadding1.prototype = _hx_e()

ComponentStorage_EchoesBenchmarkPadding1.prototype.__class__ =
   ComponentStorage_EchoesBenchmarkPadding1
ComponentStorage_EchoesBenchmarkPadding1.__super__ = __echoes_ComponentStorage
setmetatable(
   ComponentStorage_EchoesBenchmarkPadding1.prototype,
   { __index = __echoes_ComponentStorage.prototype }
)

ComponentStorage_EchoesBenchmarkPadding2.new = function()
   local self = _hx_new(ComponentStorage_EchoesBenchmarkPadding2.prototype)
   ComponentStorage_EchoesBenchmarkPadding2.super(self)
   return self
end
ComponentStorage_EchoesBenchmarkPadding2.super = function(self)
   __echoes_ComponentStorage.super(self, "EchoesBenchmark.Padding2")
end
ComponentStorage_EchoesBenchmarkPadding2.__name__ = "ComponentStorage_EchoesBenchmarkPadding2"
ComponentStorage_EchoesBenchmarkPadding2.prototype = _hx_e()

ComponentStorage_EchoesBenchmarkPadding2.prototype.__class__ =
   ComponentStorage_EchoesBenchmarkPadding2
ComponentStorage_EchoesBenchmarkPadding2.__super__ = __echoes_ComponentStorage
setmetatable(
   ComponentStorage_EchoesBenchmarkPadding2.prototype,
   { __index = __echoes_ComponentStorage.prototype }
)

ComponentStorage_EchoesBenchmarkPadding3.new = function()
   local self = _hx_new(ComponentStorage_EchoesBenchmarkPadding3.prototype)
   ComponentStorage_EchoesBenchmarkPadding3.super(self)
   return self
end
ComponentStorage_EchoesBenchmarkPadding3.super = function(self)
   __echoes_ComponentStorage.super(self, "EchoesBenchmark.Padding3")
end
ComponentStorage_EchoesBenchmarkPadding3.__name__ = "ComponentStorage_EchoesBenchmarkPadding3"
ComponentStorage_EchoesBenchmarkPadding3.prototype = _hx_e()

ComponentStorage_EchoesBenchmarkPadding3.prototype.__class__ =
   ComponentStorage_EchoesBenchmarkPadding3
ComponentStorage_EchoesBenchmarkPadding3.__super__ = __echoes_ComponentStorage
setmetatable(
   ComponentStorage_EchoesBenchmarkPadding3.prototype,
   { __index = __echoes_ComponentStorage.prototype }
)

ComponentStorage_EchoesBenchmarkPosition.new = function()
   local self = _hx_new(ComponentStorage_EchoesBenchmarkPosition.prototype)
   ComponentStorage_EchoesBenchmarkPosition.super(self)
   return self
end
ComponentStorage_EchoesBenchmarkPosition.super = function(self)
   __echoes_ComponentStorage.super(self, "EchoesBenchmark.Position")
end
ComponentStorage_EchoesBenchmarkPosition.__name__ = "ComponentStorage_EchoesBenchmarkPosition"
ComponentStorage_EchoesBenchmarkPosition.prototype = _hx_e()

ComponentStorage_EchoesBenchmarkPosition.prototype.__class__ =
   ComponentStorage_EchoesBenchmarkPosition
ComponentStorage_EchoesBenchmarkPosition.__super__ = __echoes_ComponentStorage
setmetatable(
   ComponentStorage_EchoesBenchmarkPosition.prototype,
   { __index = __echoes_ComponentStorage.prototype }
)

ComponentStorage_EchoesBenchmarkVelocity.new = function()
   local self = _hx_new(ComponentStorage_EchoesBenchmarkVelocity.prototype)
   ComponentStorage_EchoesBenchmarkVelocity.super(self)
   return self
end
ComponentStorage_EchoesBenchmarkVelocity.super = function(self)
   __echoes_ComponentStorage.super(self, "EchoesBenchmark.Velocity")
end
ComponentStorage_EchoesBenchmarkVelocity.__name__ = "ComponentStorage_EchoesBenchmarkVelocity"
ComponentStorage_EchoesBenchmarkVelocity.prototype = _hx_e()

ComponentStorage_EchoesBenchmarkVelocity.prototype.__class__ =
   ComponentStorage_EchoesBenchmarkVelocity
ComponentStorage_EchoesBenchmarkVelocity.__super__ = __echoes_ComponentStorage
setmetatable(
   ComponentStorage_EchoesBenchmarkVelocity.prototype,
   { __index = __echoes_ComponentStorage.prototype }
)

Position.new = function(x, y)
   local self = _hx_new(Position.prototype)
   Position.super(self, x, y)
   return self
end
Position.super = function(self, x, y)
   if y == nil then
      y = 0.0
   end
   if x == nil then
      x = 0.0
   end
   self.x = x
   self.y = y
end
Position.__name__ = "Position"
Position.prototype = _hx_e()

Position.prototype.__class__ = Position

Velocity.new = function(x, y)
   local self = _hx_new(Velocity.prototype)
   Velocity.super(self, x, y)
   return self
end
Velocity.super = function(self, x, y)
   if y == nil then
      y = 0.0
   end
   if x == nil then
      x = 0.0
   end
   self.x = x
   self.y = y
end
Velocity.__name__ = "Velocity"
Velocity.prototype = _hx_e()

Velocity.prototype.__class__ = Velocity

MovementSystem.new = function(priority)
   local self = _hx_new(MovementSystem.prototype)
   MovementSystem.super(self, priority)
   return self
end
MovementSystem.super = function(self, priority)
   self.timeElapsed = 0
   __echoes_System.super(self, priority)
   if self.parent ~= nil then
      local _g = 0
      local _g1 = self.__children__
      while _g < _g1.length do
         _hx_do_first_1 = false

         local child = _g1[_g]
         _g = _g + 1
         self.parent:add(child)
      end
   end
end
MovementSystem.__name__ = "MovementSystem"
MovementSystem.prototype = _hx_e()
MovementSystem.prototype.__activate__ = function(self)
   if not self.active then
      ViewOf_Position_Velocity_92d16.instance:activate()
      __echoes_System.prototype.__activate__(self)
   end
end
MovementSystem.prototype.__deactivate__ = function(self)
   if self.active then
      local _this = ViewOf_Position_Velocity_92d16.instance
      _this.activations = _this.activations - 1
      if _this.activations <= 0 then
         _this:reset()
      end
      __echoes_System.prototype.__deactivate__(self)
   end
end
MovementSystem.prototype.__update__ = function(self, dt)
   self.__dt__ = dt
   local callback = _hx_bind(self, self.__updatePosition_bridge__)
   local _g = 0
   local _g1 = ViewOf_Position_Velocity_92d16.instance._entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      local entity = _g1[_g]
      _g = _g + 1
      callback(
         entity,
         ComponentStorage_EchoesBenchmarkPosition.instance.storage[entity],
         ComponentStorage_EchoesBenchmarkVelocity.instance.storage[entity]
      )
   end
end
MovementSystem.prototype.updatePosition = function(self, position, velocity, time)
   position.x = position.x + (velocity.x * time)
   position.y = position.y + (velocity.y * time)
end
MovementSystem.prototype.__updatePosition_bridge__ = function(self, entity, position, velocity)
   self:updatePosition(position, velocity, self.__dt__)
end
MovementSystem.prototype.toString = function(self)
   do
      return "MovementSystem"
   end
end

MovementSystem.prototype.__class__ = MovementSystem
MovementSystem.__super__ = __echoes_System
setmetatable(MovementSystem.prototype, { __index = __echoes_System.prototype })

HaxeBenchmark.new = function(n_entities)
   local self = _hx_new(HaxeBenchmark.prototype)
   HaxeBenchmark.super(self, n_entities)
   return self
end
HaxeBenchmark.super = function(self, n_entities)
   __echoes_Echoes.init(0)
   self.n_entities = n_entities
end
HaxeBenchmark.__name__ = "HaxeBenchmark"
HaxeBenchmark.prototype = _hx_e()
HaxeBenchmark.prototype.iteration_teardown = function(self)
   __echoes_Echoes.reset()
end

HaxeBenchmark.prototype.__class__ = HaxeBenchmark

AddEmptyEntity.new = function(n_entities)
   local self = _hx_new(AddEmptyEntity.prototype)
   AddEmptyEntity.super(self, n_entities)
   return self
end
AddEmptyEntity.super = function(self, n_entities)
   HaxeBenchmark.super(self, n_entities)
end
AddEmptyEntity.__name__ = "AddEmptyEntity"
AddEmptyEntity.prototype = _hx_e()
AddEmptyEntity.prototype.run = function(self)
   local _g = 0
   local _g1 = self.n_entities
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      local this1
      local id = __echoes__Entity_Entity_Impl_.idPool:pop()
      if id ~= nil then
         this1 = id
      else
         this1 = (function()
            local _hx_obj = __echoes__Entity_Entity_Impl_
            local _hx_fld = "nextId"
            local _ = _hx_obj[_hx_fld]
            _hx_obj[_hx_fld] = _hx_obj[_hx_fld] + 1
            return _
         end)()
      end
      __echoes_Echoes.activeEntityIndices[this1] = __echoes_Echoes._activeEntities.length
      __echoes_Echoes._activeEntities:push(this1)
   end
end

AddEmptyEntity.prototype.__class__ = AddEmptyEntity
AddEmptyEntity.__super__ = HaxeBenchmark
setmetatable(AddEmptyEntity.prototype, { __index = HaxeBenchmark.prototype })

AddEntities.new = function(n_entities)
   local self = _hx_new(AddEntities.prototype)
   AddEntities.super(self, n_entities)
   return self
end
AddEntities.super = function(self, n_entities)
   HaxeBenchmark.super(self, n_entities)
end
AddEntities.__name__ = "AddEntities"
AddEntities.prototype = _hx_e()
AddEntities.prototype.run = function(self)
   local _g = 0
   local _g1 = self.n_entities
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      local this1
      local id = __echoes__Entity_Entity_Impl_.idPool:pop()
      if id ~= nil then
         this1 = id
      else
         this1 = (function()
            local _hx_obj = __echoes__Entity_Entity_Impl_
            local _hx_fld = "nextId"
            local _ = _hx_obj[_hx_fld]
            _hx_obj[_hx_fld] = _hx_obj[_hx_fld] + 1
            return _
         end)()
      end
      __echoes_Echoes.activeEntityIndices[this1] = __echoes_Echoes._activeEntities.length
      __echoes_Echoes._activeEntities:push(this1)
      local __entity__ = this1
      ComponentStorage_EchoesBenchmarkPosition.instance:add(__entity__, Position.new())
      ComponentStorage_EchoesBenchmarkVelocity.instance:add(__entity__, Velocity.new())
   end
end

AddEntities.prototype.__class__ = AddEntities
AddEntities.__super__ = HaxeBenchmark
setmetatable(AddEntities.prototype, { __index = HaxeBenchmark.prototype })

EntityFactory.new = function(n_entities, empty)
   local self = _hx_new(EntityFactory.prototype)
   EntityFactory.super(self, n_entities, empty)
   return self
end
EntityFactory.super = function(self, n_entities, empty)
   if empty == nil then
      empty = false
   end
   HaxeBenchmark.super(self, n_entities)
   self.entities = Array.new()
   local _g = 0
   local _g1 = self.n_entities
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      local this1
      local id = __echoes__Entity_Entity_Impl_.idPool:pop()
      if id ~= nil then
         this1 = id
      else
         this1 = (function()
            local _hx_obj = __echoes__Entity_Entity_Impl_
            local _hx_fld = "nextId"
            local _ = _hx_obj[_hx_fld]
            _hx_obj[_hx_fld] = _hx_obj[_hx_fld] + 1
            return _
         end)()
      end
      __echoes_Echoes.activeEntityIndices[this1] = __echoes_Echoes._activeEntities.length
      __echoes_Echoes._activeEntities:push(this1)
      local entity = this1
      if not empty then
         ComponentStorage_EchoesBenchmarkPosition.instance:add(entity, Position.new())
         ComponentStorage_EchoesBenchmarkVelocity.instance:add(entity, Velocity.new())
         ComponentStorage_EchoesBenchmarkOptional.instance:add(entity, true)
      end
      self.entities:push(entity)
   end
end
EntityFactory.__name__ = "EntityFactory"
EntityFactory.prototype = _hx_e()

EntityFactory.prototype.__class__ = EntityFactory
EntityFactory.__super__ = HaxeBenchmark
setmetatable(EntityFactory.prototype, { __index = HaxeBenchmark.prototype })

RemoveEntities.new = function(n_entities, empty)
   local self = _hx_new(RemoveEntities.prototype)
   RemoveEntities.super(self, n_entities, empty)
   return self
end
RemoveEntities.super = function(self, n_entities, empty)
   EntityFactory.super(self, n_entities, empty)
end
RemoveEntities.__name__ = "RemoveEntities"
RemoveEntities.prototype = _hx_e()
RemoveEntities.prototype.run = function(self)
   local _g = 0
   local _g1 = self.entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      local entity = _g1[_g]
      _g = _g + 1
      __echoes__Entity_Entity_Impl_.destroy(entity)
   end
end

RemoveEntities.prototype.__class__ = RemoveEntities
RemoveEntities.__super__ = EntityFactory
setmetatable(RemoveEntities.prototype, { __index = EntityFactory.prototype })

GetComponent.new = function(n_entities, empty)
   local self = _hx_new(GetComponent.prototype)
   GetComponent.super(self, n_entities, empty)
   return self
end
GetComponent.super = function(self, n_entities, empty)
   EntityFactory.super(self, n_entities, empty)
end
GetComponent.__name__ = "GetComponent"
GetComponent.prototype = _hx_e()
GetComponent.prototype.run = function(self)
   local _g = 0
   local _g1 = self.entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      _g = _g + 1
   end
end

GetComponent.prototype.__class__ = GetComponent
GetComponent.__super__ = EntityFactory
setmetatable(GetComponent.prototype, { __index = EntityFactory.prototype })

GetComponents.new = function(n_entities, empty)
   local self = _hx_new(GetComponents.prototype)
   GetComponents.super(self, n_entities, empty)
   return self
end
GetComponents.super = function(self, n_entities, empty)
   EntityFactory.super(self, n_entities, empty)
end
GetComponents.__name__ = "GetComponents"
GetComponents.prototype = _hx_e()
GetComponents.prototype.run = function(self)
   local _g = 0
   local _g1 = self.entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      _g = _g + 1
   end
end

GetComponents.prototype.__class__ = GetComponents
GetComponents.__super__ = EntityFactory
setmetatable(GetComponents.prototype, { __index = EntityFactory.prototype })

AddComponent.new = function(n_entities, empty)
   local self = _hx_new(AddComponent.prototype)
   AddComponent.super(self, n_entities, empty)
   return self
end
AddComponent.super = function(self, n_entities, empty)
   EntityFactory.super(self, n_entities, empty)
end
AddComponent.__name__ = "AddComponent"
AddComponent.prototype = _hx_e()
AddComponent.prototype.run = function(self)
   local _g = 0
   local _g1 = self.entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      local entity = _g1[_g]
      _g = _g + 1
      ComponentStorage_EchoesBenchmarkPosition.instance:add(entity, Position.new())
   end
end

AddComponent.prototype.__class__ = AddComponent
AddComponent.__super__ = EntityFactory
setmetatable(AddComponent.prototype, { __index = EntityFactory.prototype })

AddComponents.new = function(n_entities, empty)
   local self = _hx_new(AddComponents.prototype)
   AddComponents.super(self, n_entities, empty)
   return self
end
AddComponents.super = function(self, n_entities, empty)
   EntityFactory.super(self, n_entities, empty)
end
AddComponents.__name__ = "AddComponents"
AddComponents.prototype = _hx_e()
AddComponents.prototype.run = function(self)
   local _g = 0
   local _g1 = self.entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      local entity = _g1[_g]
      _g = _g + 1
      ComponentStorage_EchoesBenchmarkPosition.instance:add(entity, Position.new())
      ComponentStorage_EchoesBenchmarkVelocity.instance:add(entity, Velocity.new())
      ComponentStorage_EchoesBenchmarkOptional.instance:add(entity, true)
   end
end

AddComponents.prototype.__class__ = AddComponents
AddComponents.__super__ = EntityFactory
setmetatable(AddComponents.prototype, { __index = EntityFactory.prototype })

RemoveComponent.new = function(n_entities, empty)
   local self = _hx_new(RemoveComponent.prototype)
   RemoveComponent.super(self, n_entities, empty)
   return self
end
RemoveComponent.super = function(self, n_entities, empty)
   EntityFactory.super(self, n_entities, empty)
end
RemoveComponent.__name__ = "RemoveComponent"
RemoveComponent.prototype = _hx_e()
RemoveComponent.prototype.run = function(self)
   local _g = 0
   local _g1 = self.entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      local entity = _g1[_g]
      _g = _g + 1
      ComponentStorage_EchoesBenchmarkPosition.instance:remove(entity)
   end
end

RemoveComponent.prototype.__class__ = RemoveComponent
RemoveComponent.__super__ = EntityFactory
setmetatable(RemoveComponent.prototype, { __index = EntityFactory.prototype })

RemoveComponents.new = function(n_entities, empty)
   local self = _hx_new(RemoveComponents.prototype)
   RemoveComponents.super(self, n_entities, empty)
   return self
end
RemoveComponents.super = function(self, n_entities, empty)
   EntityFactory.super(self, n_entities, empty)
end
RemoveComponents.__name__ = "RemoveComponents"
RemoveComponents.prototype = _hx_e()
RemoveComponents.prototype.run = function(self)
   local _g = 0
   local _g1 = self.entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      local entity = _g1[_g]
      _g = _g + 1
      ComponentStorage_EchoesBenchmarkPosition.instance:remove(entity)
      ComponentStorage_EchoesBenchmarkVelocity.instance:remove(entity)
      ComponentStorage_EchoesBenchmarkOptional.instance:remove(entity)
   end
end

RemoveComponents.prototype.__class__ = RemoveComponents
RemoveComponents.__super__ = EntityFactory
setmetatable(RemoveComponents.prototype, { __index = EntityFactory.prototype })

SystemUpdate.new = function(n_entities)
   local self = _hx_new(SystemUpdate.prototype)
   SystemUpdate.super(self, n_entities)
   return self
end
SystemUpdate.super = function(self, n_entities)
   HaxeBenchmark.super(self, n_entities)
   local _g = 0
   local _g1 = self.n_entities
   while _g < _g1 do
      _hx_do_first_1 = false

      _g = _g + 1
      local i = _g - 1
      local this1
      local id = __echoes__Entity_Entity_Impl_.idPool:pop()
      if id ~= nil then
         this1 = id
      else
         this1 = (function()
            local _hx_obj = __echoes__Entity_Entity_Impl_
            local _hx_fld = "nextId"
            local _ = _hx_obj[_hx_fld]
            _hx_obj[_hx_fld] = _hx_obj[_hx_fld] + 1
            return _
         end)()
      end
      __echoes_Echoes.activeEntityIndices[this1] = __echoes_Echoes._activeEntities.length
      __echoes_Echoes._activeEntities:push(this1)
      local __entity__ = this1
      ComponentStorage_EchoesBenchmarkPosition.instance:add(__entity__, Position.new())
      ComponentStorage_EchoesBenchmarkVelocity.instance:add(__entity__, Velocity.new())
      local padding = _G.math.fmod(i, 4)
      if padding == 1 then
         ComponentStorage_EchoesBenchmarkPadding1.instance:add(__entity__, true)
      elseif padding == 2 then
         ComponentStorage_EchoesBenchmarkPadding2.instance:add(__entity__, true)
      elseif padding == 3 then
         ComponentStorage_EchoesBenchmarkPadding3.instance:add(__entity__, true)
      else
      end
      local shuffle = _G.math.fmod((i + 1), 4)
      if shuffle == 0 then
         ComponentStorage_EchoesBenchmarkPosition.instance:remove(__entity__)
      elseif shuffle == 1 then
         ComponentStorage_EchoesBenchmarkVelocity.instance:remove(__entity__)
      else
      end
   end
   local _this = MovementSystem.new()
   __echoes_Echoes.activeSystems:add(_this)
end
SystemUpdate.__name__ = "SystemUpdate"
SystemUpdate.prototype = _hx_e()
SystemUpdate.prototype.run = function(self)
   __echoes_Echoes.update()
end

SystemUpdate.prototype.__class__ = SystemUpdate
SystemUpdate.__super__ = HaxeBenchmark
setmetatable(SystemUpdate.prototype, { __index = HaxeBenchmark.prototype })

Lambda.new = {}
Lambda.__name__ = "Lambda"
Lambda.has = function(it, elt)
   local x = it:iterator()
   while x:hasNext() do
      _hx_do_first_1 = false

      if x:next() == elt then
         do
            return true
         end
      end
   end
   do
      return false
   end
end
Lambda.findIndex = function(it, f)
   local i = 0
   local v = it:iterator()
   while v:hasNext() do
      _hx_do_first_1 = false

      if f(v:next()) then
         do
            return i
         end
      end
      i = i + 1
   end
   do
      return -1
   end
end

Math.new = {}
Math.__name__ = "Math"
Math.isNaN = function(f)
   do
      return f ~= f
   end
end
Math.isFinite = function(f)
   if f > -_G.math.huge then
      do
         return f < _G.math.huge
      end
   else
      do
         return false
      end
   end
end
Math.min = function(a, b)
   if Math.isNaN(a) or Math.isNaN(b) then
      do
         return (0 / 0)
      end
   else
      do
         return _G.math.min(a, b)
      end
   end
end

Reflect.new = {}
Reflect.__name__ = "Reflect"
Reflect.compareMethods = function(f1, f2)
   do
      return f1 == f2
   end
end

String.new = function(string)
   local self = _hx_new(String.prototype)
   String.super(self, string)
   self = string
   return self
end
String.super = function(self, string) end
String.__name__ = "String"
String.__index = function(s, k)
   if k == "length" then
      do
         return __lua_lib_luautf8_Utf8.len(s)
      end
   else
      local o = String.prototype
      local field = k
      if
         (function()
            local _hx_1
            if
               (_G.type(o) == "function")
               and not (
                  (function()
                     local _hx_2
                     if _G.type(o) ~= "table" then
                        _hx_2 = false
                     else
                        _hx_2 = o.__name__
                     end
                     return _hx_2
                  end)()
                  or (function()
                     local _hx_3
                     if _G.type(o) ~= "table" then
                        _hx_3 = false
                     else
                        _hx_3 = o.__ename__
                     end
                     return _hx_3
                  end)()
               )
            then
               _hx_1 = false
            elseif
               (_G.type(o) == "string") and (
                  (String.prototype[field] ~= nil) or (field == "length")
               )
            then
               _hx_1 = true
            elseif o.__fields__ ~= nil then
               _hx_1 = o.__fields__[field] ~= nil
            else
               _hx_1 = o[field] ~= nil
            end
            return _hx_1
         end)()
      then
         do
            return String.prototype[k]
         end
      else
         if String.__oldindex ~= nil then
            if _G.type(String.__oldindex) == "function" then
               do
                  return String.__oldindex(s, k)
               end
            else
               if _G.type(String.__oldindex) == "table" then
                  do
                     return String.__oldindex[k]
                  end
               end
            end
            do
               return nil
            end
         else
            do
               return nil
            end
         end
      end
   end
end
String.indexOfEmpty = function(s, startIndex)
   local length = __lua_lib_luautf8_Utf8.len(s)
   if startIndex < 0 then
      startIndex = length + startIndex
      if startIndex < 0 then
         startIndex = 0
      end
   end
   if startIndex > length then
      do
         return length
      end
   else
      do
         return startIndex
      end
   end
end
String.fromCharCode = function(code)
   do
      return __lua_lib_luautf8_Utf8.char(code)
   end
end
String.prototype = _hx_e()
String.prototype.toUpperCase = function(self)
   do
      return __lua_lib_luautf8_Utf8.upper(self)
   end
end
String.prototype.toLowerCase = function(self)
   do
      return __lua_lib_luautf8_Utf8.lower(self)
   end
end
String.prototype.indexOf = function(self, str, startIndex)
   if startIndex == nil then
      startIndex = 1
   else
      startIndex = startIndex + 1
   end
   if str == "" then
      do
         return String.indexOfEmpty(self, startIndex - 1)
      end
   end
   local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex, true)
   if (r ~= nil) and (r > 0) then
      do
         return r - 1
      end
   else
      do
         return -1
      end
   end
end
String.prototype.lastIndexOf = function(self, str, startIndex)
   local ret = -1
   if startIndex == nil then
      startIndex = __lua_lib_luautf8_Utf8.len(self)
   end
   while true do
      _hx_do_first_1 = false

      local p = String.prototype.indexOf(self, str, ret + 1)
      if ((p == -1) or (p > startIndex)) or (p == ret) then
         break
      end
      ret = p
   end
   do
      return ret
   end
end
String.prototype.split = function(self, delimiter)
   local idx = 1
   local ret = _hx_tab_array({}, 0)
   while idx ~= nil do
      _hx_do_first_1 = false

      local newidx = 0
      if __lua_lib_luautf8_Utf8.len(delimiter) > 0 then
         newidx = __lua_lib_luautf8_Utf8.find(self, delimiter, idx, true)
      else
         if idx >= __lua_lib_luautf8_Utf8.len(self) then
            newidx = nil
         else
            newidx = idx + 1
         end
      end
      if newidx ~= nil then
         local match = __lua_lib_luautf8_Utf8.sub(self, idx, newidx - 1)
         ret:push(match)
         idx = newidx + __lua_lib_luautf8_Utf8.len(delimiter)
      else
         ret:push(__lua_lib_luautf8_Utf8.sub(self, idx, __lua_lib_luautf8_Utf8.len(self)))
         idx = nil
      end
   end
   do
      return ret
   end
end
String.prototype.toString = function(self)
   do
      return self
   end
end
String.prototype.substring = function(self, startIndex, endIndex)
   if endIndex == nil then
      endIndex = __lua_lib_luautf8_Utf8.len(self)
   end
   if endIndex < 0 then
      endIndex = 0
   end
   if startIndex < 0 then
      startIndex = 0
   end
   if endIndex < startIndex then
      do
         return __lua_lib_luautf8_Utf8.sub(self, endIndex + 1, startIndex)
      end
   else
      do
         return __lua_lib_luautf8_Utf8.sub(self, startIndex + 1, endIndex)
      end
   end
end
String.prototype.charAt = function(self, index)
   do
      return __lua_lib_luautf8_Utf8.sub(self, index + 1, index + 1)
   end
end
String.prototype.charCodeAt = function(self, index)
   do
      return __lua_lib_luautf8_Utf8.byte(self, index + 1)
   end
end
String.prototype.substr = function(self, pos, len)
   if (len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(self))) then
      len = __lua_lib_luautf8_Utf8.len(self)
   else
      if len < 0 then
         len = __lua_lib_luautf8_Utf8.len(self) + len
      end
   end
   if pos < 0 then
      pos = __lua_lib_luautf8_Utf8.len(self) + pos
   end
   if pos < 0 then
      pos = 0
   end
   do
      return __lua_lib_luautf8_Utf8.sub(self, pos + 1, pos + len)
   end
end

String.prototype.__class__ = String

Std.new = {}
Std.__name__ = "Std"
Std.string = function(s)
   do
      return _hx_tostring(s, 0)
   end
end
Std.int = function(x)
   if not Math.isFinite(x) or Math.isNaN(x) then
      do
         return 0
      end
   else
      do
         return _hx_bit_clamp(x)
      end
   end
end

Type.new = {}
Type.__name__ = "Type"
Type.getClass = function(o)
   if o == nil then
      do
         return nil
      end
   end
   local o = o
   if __lua_Boot.__instanceof(o, Array) then
      do
         return Array
      end
   else
      if __lua_Boot.__instanceof(o, String) then
         do
            return String
         end
      else
         local cl = o.__class__
         if cl ~= nil then
            do
               return cl
            end
         else
            do
               return nil
            end
         end
      end
   end
end

__echoes_ViewBase.new = function()
   local self = _hx_new(__echoes_ViewBase.prototype)
   __echoes_ViewBase.super(self)
   return self
end
__echoes_ViewBase.super = function(self)
   self.activations = 0
   self._entities = _hx_tab_array({}, 0)
end
__echoes_ViewBase.__name__ = "echoes.ViewBase"
__echoes_ViewBase.prototype = _hx_e()
__echoes_ViewBase.prototype.get_entities = function(self)
   do
      return self._entities
   end
end
__echoes_ViewBase.prototype.get_active = function(self)
   do
      return self.activations > 0
   end
end
__echoes_ViewBase.prototype.activate = function(self)
   self.activations = self.activations + 1
   if self.activations == 1 then
      __echoes_Echoes._activeViews:push(self)
      local _g = 0
      local _g1 = __echoes_Echoes._activeEntities
      while _g < _g1.length do
         _hx_do_first_1 = false

         local e = _g1[_g]
         _g = _g + 1
         if self:isMatched(e) then
            if not self._entities:contains(e) then
               self._entities:push(e)
            end
            self:dispatchAddedCallback(e)
         end
      end
   end
end
__echoes_ViewBase.prototype.add = function(self, entity)
   if self:isMatched(entity) then
      if not self._entities:contains(entity) then
         self._entities:push(entity)
      end
      self:dispatchAddedCallback(entity)
   end
end
__echoes_ViewBase.prototype.deactivate = function(self)
   self.activations = self.activations - 1
   if self.activations <= 0 then
      self:reset()
   end
end
__echoes_ViewBase.prototype.dispatchAddedCallback = function(self, entity) end
__echoes_ViewBase.prototype.dispatchRemovedCallback = function(
   self,
   entity,
   removedComponentStorage,
   removedComponent
)
end
__echoes_ViewBase.prototype.isMatched = function(self, entity)
   do
      return false
   end
end
__echoes_ViewBase.prototype.remove = function(
   self,
   entity,
   removedComponentStorage,
   removedComponent
)
   local index = self._entities:lastIndexOf(entity)
   if index >= 0 then
      self._entities[index] = self._entities[self._entities.length - 1]
      self._entities:pop()
      self:dispatchRemovedCallback(entity, removedComponentStorage, removedComponent)
   end
end
__echoes_ViewBase.prototype.reset = function(self)
   self.activations = 0
   __echoes_Echoes._activeViews:remove(self)
   self._entities:resize(0)
end
__echoes_ViewBase.prototype.toString = function(self)
   do
      return "ViewBase"
   end
end

__echoes_ViewBase.prototype.__class__ = __echoes_ViewBase

ViewOf_Position_Velocity_92d16.new = function()
   local self = _hx_new(ViewOf_Position_Velocity_92d16.prototype)
   ViewOf_Position_Velocity_92d16.super(self)
   return self
end
ViewOf_Position_Velocity_92d16.super = function(self)
   self.onRemoved = Array.new()
   self.onAdded = Array.new()
   __echoes_ViewBase.super(self)
end
ViewOf_Position_Velocity_92d16.__name__ = "ViewOf_Position_Velocity_92d16"
ViewOf_Position_Velocity_92d16.prototype = _hx_e()
ViewOf_Position_Velocity_92d16.prototype.activate = function(self)
   __echoes_ViewBase.prototype.activate(self)
   if self.activations == 1 then
      ComponentStorage_EchoesBenchmarkPosition.instance._relatedViews:push(self)
      ComponentStorage_EchoesBenchmarkVelocity.instance._relatedViews:push(self)
   end
end
ViewOf_Position_Velocity_92d16.prototype.dispatchAddedCallback = function(self, entity)
   local index = self._entities:lastIndexOf(entity)
   local _g = 0
   local _g1 = self.onAdded
   while _g < _g1.length do
      _hx_do_first_1 = false

      local callback = _g1[_g]
      _g = _g + 1
      callback(
         entity,
         ComponentStorage_EchoesBenchmarkPosition.instance.storage[entity],
         ComponentStorage_EchoesBenchmarkVelocity.instance.storage[entity]
      )
      if self._entities[index] ~= entity then
         index = self._entities:indexOf(entity)
         if self._entities[index] ~= entity then
            break
         end
      end
   end
end
ViewOf_Position_Velocity_92d16.prototype.dispatchRemovedCallback = function(
   self,
   entity,
   removedComponentStorage,
   removedComponent
)
   local exception = nil
   local _g = 0
   local _g1 = self.onRemoved
   while _g < _g1.length do
      _hx_do_first_1 = false

      local callback = _g1[_g]
      _g = _g + 1
      local _hx_status, _hx_result = pcall(function()
         callback(
            entity,
            (function()
               local _hx_1
               if ComponentStorage_EchoesBenchmarkPosition.instance == removedComponentStorage then
                  _hx_1 = removedComponent
               else
                  _hx_1 = ComponentStorage_EchoesBenchmarkPosition.instance.storage[entity]
               end
               return _hx_1
            end)(),
            (function()
               local _hx_2
               if ComponentStorage_EchoesBenchmarkVelocity.instance == removedComponentStorage then
                  _hx_2 = removedComponent
               else
                  _hx_2 = ComponentStorage_EchoesBenchmarkVelocity.instance.storage[entity]
               end
               return _hx_2
            end)()
         )
         return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
         break
      elseif not _hx_status then
         local _g = _hx_result
         exception = __haxe_Exception.caught(_g)
      elseif _hx_result ~= _hx_pcall_default then
         return _hx_result
      end
   end
   if exception ~= nil then
      _G.error(__haxe_Exception.thrown(exception), 0)
   end
end
ViewOf_Position_Velocity_92d16.prototype.reset = function(self)
   __echoes_ViewBase.prototype.reset(self)
   self.onAdded:resize(0)
   self.onRemoved:resize(0)
   ComponentStorage_EchoesBenchmarkPosition.instance._relatedViews:remove(self)
   ComponentStorage_EchoesBenchmarkVelocity.instance._relatedViews:remove(self)
end
ViewOf_Position_Velocity_92d16.prototype.iter = function(self, callback)
   local _g = 0
   local _g1 = self._entities
   while _g < _g1.length do
      _hx_do_first_1 = false

      local entity = _g1[_g]
      _g = _g + 1
      callback(
         entity,
         ComponentStorage_EchoesBenchmarkPosition.instance.storage[entity],
         ComponentStorage_EchoesBenchmarkVelocity.instance.storage[entity]
      )
   end
end
ViewOf_Position_Velocity_92d16.prototype.isMatched = function(self, entity)
   if ComponentStorage_EchoesBenchmarkVelocity.instance.storage[entity] ~= nil then
      do
         return ComponentStorage_EchoesBenchmarkPosition.instance.storage[entity] ~= nil
      end
   else
      do
         return false
      end
   end
end
ViewOf_Position_Velocity_92d16.prototype.toString = function(self)
   do
      return "EchoesBenchmark.Position, EchoesBenchmark.Velocity"
   end
end

ViewOf_Position_Velocity_92d16.prototype.__class__ = ViewOf_Position_Velocity_92d16
ViewOf_Position_Velocity_92d16.__super__ = __echoes_ViewBase
setmetatable(ViewOf_Position_Velocity_92d16.prototype, { __index = __echoes_ViewBase.prototype })

__echoes__ComponentStorage_DynamicComponentStorage_Impl_.new = {}
__echoes__ComponentStorage_DynamicComponentStorage_Impl_.__name__ =
   "echoes._ComponentStorage.DynamicComponentStorage_Impl_"
__echoes__ComponentStorage_DynamicComponentStorage_Impl_.fromComponentStorage = function(
   componentStorage
)
   do
      return componentStorage
   end
end

__echoes__ComponentStorage_EntityComponents_Impl_.new = {}
__echoes__ComponentStorage_EntityComponents_Impl_.__name__ =
   "echoes._ComponentStorage.EntityComponents_Impl_"
__echoes__ComponentStorage_EntityComponents_Impl_.addComponentStorage = function(this1, storage)
   if not this1:contains(storage) then
      this1:push(storage)
   end
end
__echoes__ComponentStorage_EntityComponents_Impl_.forEntity = function(entity)
   if __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] == nil then
      __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = Array.new()
      do
         return __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
      end
   else
      do
         return __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
      end
   end
end
__echoes__ComponentStorage_EntityComponents_Impl_.removeAll = function(entity)
   local entityComponents = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
   if entityComponents ~= nil then
      __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = Array.new()
      local _g_current = 0
      local _g_array = entityComponents
      while _g_current < _g_array.length do
         _hx_do_first_1 = false

         _g_current = _g_current + 1
         _g_array[_g_current - 1]:remove(entity)
      end
   end
end
__echoes__ComponentStorage_EntityComponents_Impl_.removeComponentStorage = function(this1, storage)
   local index = this1:lastIndexOf(storage)
   if index >= 0 then
      this1[index] = this1[this1.length - 1]
      this1:pop()
      do
         return true
      end
   else
      do
         return false
      end
   end
end
__echoes__ComponentStorage_EntityComponents_Impl_.toIterable = function(this1)
   do
      return this1
   end
end
__echoes__ComponentStorage_EntityComponents_Impl_.toMap = function(this1)
   local entity
   local _g = __echoes__ComponentStorage_EntityComponents_Impl_.components:indexOf(this1)
   if _g == -1 then
      _G.error(__haxe_Exception.thrown("This EntityComponents instance was disposed."), 0)
   else
      entity = _g
   end
   local _g = __haxe_ds_StringMap.new()
   local _g_current = 0
   local _g_array = this1
   while _g_current < _g_array.length do
      _hx_do_first_1 = false

      _g_current = _g_current + 1
      local storage = _g_array[_g_current - 1]
      local key = storage.componentType
      local value = storage.storage[entity]
      if value == nil then
         _g.h[key] = __haxe_ds_StringMap.tnull
      else
         _g.h[key] = value
      end
   end
   do
      return _g
   end
end

__echoes__Entity_Entity_Impl_.new = {}
__echoes__Entity_Entity_Impl_.__name__ = "echoes._Entity.Entity_Impl_"
__echoes__Entity_Entity_Impl_.get_active = function(this1)
   do
      return __echoes_Echoes.activeEntityIndices[this1] ~= nil
   end
end
__echoes__Entity_Entity_Impl_.get_destroyed = function(this1)
   if __echoes_Echoes.activeEntityIndices[this1] == nil then
      do
         return __echoes__Entity_Entity_Impl_.idPool:contains(this1)
      end
   else
      do
         return false
      end
   end
end
__echoes__Entity_Entity_Impl_.get_id = function(this1)
   do
      return this1
   end
end
__echoes__Entity_Entity_Impl_._new = function(active)
   if active == nil then
      active = true
   end
   local this1
   local id = __echoes__Entity_Entity_Impl_.idPool:pop()
   if id ~= nil then
      this1 = id
   else
      this1 = (function()
         local _hx_obj = __echoes__Entity_Entity_Impl_
         local _hx_fld = "nextId"
         local _ = _hx_obj[_hx_fld]
         _hx_obj[_hx_fld] = _hx_obj[_hx_fld] + 1
         return _
      end)()
   end
   if active then
      __echoes_Echoes.activeEntityIndices[this1] = __echoes_Echoes._activeEntities.length
      __echoes_Echoes._activeEntities:push(this1)
   end
   do
      return this1
   end
end
__echoes__Entity_Entity_Impl_.activate = function(this1)
   if __echoes_Echoes.activeEntityIndices[this1] == nil then
      __echoes_Echoes.activeEntityIndices[this1] = __echoes_Echoes._activeEntities.length
      __echoes_Echoes._activeEntities:push(this1)
      local entity = this1
      local _g_current = 0
      local _g_array = (function()
         local _hx_1
         if __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] == nil then
            __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = Array.new()
            _hx_1 = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
         else
            _hx_1 = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
         end
         return _hx_1
      end)()
      while _g_current < _g_array.length do
         _hx_do_first_1 = false

         _g_current = _g_current + 1
         local _g = 0
         local _g1 = _g_array[_g_current - 1]._relatedViews
         while _g < _g1.length do
            _hx_do_first_2 = false

            local view = _g1[_g]
            _g = _g + 1
            local entity = this1
            if view:isMatched(entity) then
               if not view._entities:contains(entity) then
                  view._entities:push(entity)
               end
               view:dispatchAddedCallback(entity)
            end
         end
      end
   end
end
__echoes__Entity_Entity_Impl_.deactivate = function(this1)
   if __echoes_Echoes.activeEntityIndices[this1] ~= nil then
      local index = __echoes_Echoes.activeEntityIndices[this1]
      if index >= 0 then
         __echoes_Echoes.activeEntityIndices[this1] = nil
         local lastEntity = __echoes_Echoes._activeEntities:pop()
         if lastEntity ~= this1 then
            __echoes_Echoes.activeEntityIndices[lastEntity] = index
            __echoes_Echoes._activeEntities[index] = lastEntity
         end
      end
      local entity = this1
      local _g_current = 0
      local _g_array = (function()
         local _hx_1
         if __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] == nil then
            __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = Array.new()
            _hx_1 = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
         else
            _hx_1 = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
         end
         return _hx_1
      end)()
      while _g_current < _g_array.length do
         _hx_do_first_1 = false

         _g_current = _g_current + 1
         local _g = 0
         local _g1 = _g_array[_g_current - 1]._relatedViews
         while _g < _g1.length do
            _hx_do_first_2 = false

            local view = _g1[_g]
            _g = _g + 1
            local entity = this1
            local removedComponentStorage = nil
            local removedComponent = nil
            local index = view._entities:lastIndexOf(entity)
            if index >= 0 then
               view._entities[index] = view._entities[view._entities.length - 1]
               view._entities:pop()
               view:dispatchRemovedCallback(entity, removedComponentStorage, removedComponent)
            end
         end
      end
   end
end
__echoes__Entity_Entity_Impl_.destroy = function(this1)
   if
      not (
         (__echoes_Echoes.activeEntityIndices[this1] == nil)
         and __echoes__Entity_Entity_Impl_.idPool:contains(this1)
      )
   then
      local entity = this1
      local entityComponents = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
      if entityComponents ~= nil then
         __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = Array.new()
         local _g_current = 0
         local _g_array = entityComponents
         while _g_current < _g_array.length do
            _hx_do_first_1 = false

            _g_current = _g_current + 1
            _g_array[_g_current - 1]:remove(entity)
         end
      end
      __echoes__Entity_Entity_Impl_.deactivate(this1)
      __echoes__Entity_Entity_Impl_.idPool:push(this1)
   end
end
__echoes__Entity_Entity_Impl_.getComponents = function(this1)
   local entity = this1
   if __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] == nil then
      __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = Array.new()
      do
         return __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
      end
   else
      do
         return __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
      end
   end
end
__echoes__Entity_Entity_Impl_.removeAll = function(this1)
   local entity = this1
   local entityComponents = __echoes__ComponentStorage_EntityComponents_Impl_.components[entity]
   if entityComponents ~= nil then
      __echoes__ComponentStorage_EntityComponents_Impl_.components[entity] = Array.new()
      local _g_current = 0
      local _g_array = entityComponents
      while _g_current < _g_array.length do
         _hx_do_first_1 = false

         _g_current = _g_current + 1
         _g_array[_g_current - 1]:remove(entity)
      end
   end
end

__echoes__Entity_Entity_Fields_.new = {}
__echoes__Entity_Entity_Fields_.__name__ = "echoes._Entity.Entity_Fields_"

__echoes__System_ChildSystem.new = function(parentSystem, priority, runUpdateListeners)
   local self = _hx_new(__echoes__System_ChildSystem.prototype)
   __echoes__System_ChildSystem.super(self, parentSystem, priority, runUpdateListeners)
   return self
end
__echoes__System_ChildSystem.super = function(self, parentSystem, priority, runUpdateListeners)
   __echoes_System.super(self, priority)
   self.parentSystem = parentSystem
   self.runUpdateListeners = runUpdateListeners
end
__echoes__System_ChildSystem.__name__ = "echoes._System.ChildSystem"
__echoes__System_ChildSystem.prototype = _hx_e()
__echoes__System_ChildSystem.prototype.__update__ = function(self, dt)
   self.runUpdateListeners(dt)
end
__echoes__System_ChildSystem.prototype.toString = function(self)
   do
      return Std.string(self.parentSystem:toString())
         .. Std.string((Std.string(":") .. Std.string(self.priority)))
   end
end

__echoes__System_ChildSystem.prototype.__class__ = __echoes__System_ChildSystem
__echoes__System_ChildSystem.__super__ = __echoes_System
setmetatable(__echoes__System_ChildSystem.prototype, { __index = __echoes_System.prototype })

__echoes_View.new = function()
   local self = _hx_new(__echoes_View.prototype)
   __echoes_View.super(self)
   return self
end
__echoes_View.super = function(self)
   __echoes_ViewBase.super(self)
end
__echoes_View.__name__ = "echoes.View"
__echoes_View.prototype = _hx_e()

__echoes_View.prototype.__class__ = __echoes_View
__echoes_View.__super__ = __echoes_ViewBase
setmetatable(__echoes_View.prototype, { __index = __echoes_ViewBase.prototype })

__echoes_utils__ComponentTypes_ComponentTypes_Impl_.new = {}
__echoes_utils__ComponentTypes_ComponentTypes_Impl_.__name__ =
   "echoes.utils._ComponentTypes.ComponentTypes_Impl_"
__echoes_utils__ComponentTypes_ComponentTypes_Impl_.addComponentStorage = function(this1, storage)
   if not this1:contains(storage) then
      this1:push(storage)
   end
end
__echoes_utils__ComponentTypes_ComponentTypes_Impl_.containsComponentStorage = function(
   this1,
   storage
)
   do
      return this1:contains(storage)
   end
end
__echoes_utils__ComponentTypes_ComponentTypes_Impl_.iterator = function(this1)
   do
      return __haxe_iterators_ArrayIterator.new(this1)
   end
end
__echoes_utils__ComponentTypes_ComponentTypes_Impl_.removeComponentStorage = function(
   this1,
   storage
)
   local index = this1:lastIndexOf(storage)
   if index >= 0 then
      this1[index] = this1[this1.length - 1]
      this1:pop()
      do
         return true
      end
   else
      do
         return false
      end
   end
end
__echoes_utils__ComponentTypes_ComponentTypes_Impl_.toIterable = function(this1)
   do
      return this1
   end
end

__echoes_utils__ReadOnlyData_ReadOnlyList_Impl_.new = {}
__echoes_utils__ReadOnlyData_ReadOnlyList_Impl_.__name__ =
   "echoes.utils._ReadOnlyData.ReadOnlyList_Impl_"
__echoes_utils__ReadOnlyData_ReadOnlyList_Impl_.has = function(this1, item)
   do
      return Lambda.has(this1, item)
   end
end

__echoes_utils__Signal_Signal_Impl_.new = {}
__echoes_utils__Signal_Signal_Impl_.__name__ = "echoes.utils._Signal.Signal_Impl_"
__echoes_utils__Signal_Signal_Impl_.add = function(this1, listener)
   this1:push(listener)
end
__echoes_utils__Signal_Signal_Impl_.contains = function(this1, listener)
   local _g = 0
   while _g < this1.length do
      _hx_do_first_1 = false

      local l = this1[_g]
      _g = _g + 1
      if Reflect.compareMethods(l, listener) then
         do
            return true
         end
      end
   end
   do
      return false
   end
end
__echoes_utils__Signal_Signal_Impl_.indexOf = function(this1, listener)
   local _g_current = 0
   while _g_current < this1.length do
      _hx_do_first_1 = false

      local _g_value = this1[_g_current]
      _g_current = _g_current + 1
      if Reflect.compareMethods(_g_value, listener) then
         do
            return _g_current - 1
         end
      end
   end
   do
      return -1
   end
end
__echoes_utils__Signal_Signal_Impl_.remove = function(this1, listener)
   local _g_current = 0
   while _g_current < this1.length do
      _hx_do_first_1 = false

      local _g_value = this1[_g_current]
      _g_current = _g_current + 1
      if Reflect.compareMethods(_g_value, listener) then
         this1:splice(_g_current - 1, 1)
         do
            return true
         end
      end
   end
   do
      return false
   end
end

__haxe_IMap.new = {}
__haxe_IMap.__name__ = "haxe.IMap"

__haxe_EntryPoint.new = {}
__haxe_EntryPoint.__name__ = "haxe.EntryPoint"
__haxe_EntryPoint.processEvents = function()
   while true do
      _hx_do_first_1 = false

      local f = __haxe_EntryPoint.pending:shift()
      if f == nil then
         break
      end
      f()
   end
   local time = __haxe_MainLoop.tick()
   if not __haxe_MainLoop.hasEvents() and (__haxe_EntryPoint.threadCount == 0) then
      do
         return -1
      end
   end
   do
      return time
   end
end
__haxe_EntryPoint.run = function()
   while true do
      _hx_do_first_1 = false

      local nextTick = __haxe_EntryPoint.processEvents()
      if _hx_luv.loop_alive() then
         if nextTick < 0 then
            _hx_luv.run("once")
         else
            _hx_luv.run("nowait")
         end
      else
         if nextTick < 0 then
            break
         end
         local tmp = nextTick > 0
      end
   end
end

__haxe_Exception.new = function(message, previous, native)
   local self = _hx_new(__haxe_Exception.prototype)
   __haxe_Exception.super(self, message, previous, native)
   return self
end
__haxe_Exception.super = function(self, message, previous, native)
   self.__skipStack = 0
   self.__exceptionMessage = message
   self.__previousException = previous
   if native ~= nil then
      self.__nativeException = native
      self.__nativeStack = __haxe_NativeStackTrace.exceptionStack()
   else
      self.__nativeException = self
      self.__nativeStack = __haxe_NativeStackTrace.callStack()
      self.__skipStack = 1
   end
end
__haxe_Exception.__name__ = "haxe.Exception"
__haxe_Exception.caught = function(value)
   if __lua_Boot.__instanceof(value, __haxe_Exception) then
      do
         return value
      end
   else
      do
         return __haxe_ValueException.new(value, nil, value)
      end
   end
end
__haxe_Exception.thrown = function(value)
   if __lua_Boot.__instanceof(value, __haxe_Exception) then
      do
         return value:get_native()
      end
   else
      local e = __haxe_ValueException.new(value)
      e.__skipStack = e.__skipStack + 1
      do
         return e
      end
   end
end
__haxe_Exception.prototype = _hx_e()
__haxe_Exception.prototype.toString = function(self)
   do
      return self:get_message()
   end
end
__haxe_Exception.prototype.get_message = function(self)
   do
      return self.__exceptionMessage
   end
end
__haxe_Exception.prototype.get_native = function(self)
   do
      return self.__nativeException
   end
end

__haxe_Exception.prototype.__class__ = __haxe_Exception

__haxe_MainEvent.new = function(f, p)
   local self = _hx_new(__haxe_MainEvent.prototype)
   __haxe_MainEvent.super(self, f, p)
   return self
end
__haxe_MainEvent.super = function(self, f, p)
   self.isBlocking = true
   self.f = f
   self.priority = p
   self.nextRun = -_G.math.huge
end
__haxe_MainEvent.__name__ = "haxe.MainEvent"
__haxe_MainEvent.prototype = _hx_e()
__haxe_MainEvent.prototype.delay = function(self, t)
   self.nextRun = (function()
      local _hx_1
      if t == nil then
         _hx_1 = -_G.math.huge
      else
         _hx_1 = Sys.time() + t
      end
      return _hx_1
   end)()
end
__haxe_MainEvent.prototype.stop = function(self)
   if self.f == nil then
      do
         return
      end
   end
   self.f = nil
   self.nextRun = -_G.math.huge
   if self.prev == nil then
      __haxe_MainLoop.pending = self.next
   else
      self.prev.next = self.next
   end
   if self.next ~= nil then
      self.next.prev = self.prev
   end
end

__haxe_MainEvent.prototype.__class__ = __haxe_MainEvent

__haxe_MainLoop.new = {}
__haxe_MainLoop.__name__ = "haxe.MainLoop"
__haxe_MainLoop.hasEvents = function()
   local p = __haxe_MainLoop.pending
   while p ~= nil do
      _hx_do_first_1 = false

      if p.isBlocking then
         do
            return true
         end
      end
      p = p.next
   end
   do
      return false
   end
end
__haxe_MainLoop.add = function(f, priority)
   if priority == nil then
      priority = 0
   end
   if f == nil then
      _G.error(__haxe_Exception.thrown("Event function is null"), 0)
   end
   local e = __haxe_MainEvent.new(f, priority)
   local head = __haxe_MainLoop.pending
   if head ~= nil then
      head.prev = e
   end
   e.next = head
   __haxe_MainLoop.pending = e
   do
      return e
   end
end
__haxe_MainLoop.sortEvents = function()
   local list = __haxe_MainLoop.pending
   if list == nil then
      do
         return
      end
   end
   local insize = 1
   local nmerges
   local psize = 0
   local qsize = 0
   local p
   local q
   local e
   local tail
   while true do
      _hx_do_first_1 = false

      p = list
      list = nil
      tail = nil
      nmerges = 0
      while p ~= nil do
         _hx_do_first_2 = false

         nmerges = nmerges + 1
         q = p
         psize = 0
         local _g = 0
         local _g1 = insize
         while _g < _g1 do
            _hx_do_first_3 = false

            _g = _g + 1
            psize = psize + 1
            q = q.next
            if q == nil then
               break
            end
         end
         qsize = insize
         while (psize > 0) or ((qsize > 0) and (q ~= nil)) do
            _hx_do_first_3 = false

            if psize == 0 then
               e = q
               q = q.next
               qsize = qsize - 1
            else
               if
                  ((qsize == 0) or (q == nil))
                  or (
                     (p.priority > q.priority)
                     or ((p.priority == q.priority) and (p.nextRun <= q.nextRun))
                  )
               then
                  e = p
                  p = p.next
                  psize = psize - 1
               else
                  e = q
                  q = q.next
                  qsize = qsize - 1
               end
            end
            if tail ~= nil then
               tail.next = e
            else
               list = e
            end
            e.prev = tail
            tail = e
         end
         p = q
      end
      tail.next = nil
      if nmerges <= 1 then
         break
      end
      insize = insize * 2
   end
   list.prev = nil
   __haxe_MainLoop.pending = list
end
__haxe_MainLoop.tick = function()
   __haxe_MainLoop.sortEvents()
   local e = __haxe_MainLoop.pending
   local now = Sys.time()
   local wait = 1e9
   while e ~= nil do
      _hx_do_first_1 = false

      local next = e.next
      local wt = e.nextRun - now
      if wt <= 0 then
         wait = 0
         if e.f ~= nil then
            e.f()
         end
      else
         if wait > wt then
            wait = wt
         end
      end
      e = next
   end
   do
      return wait
   end
end

__haxe_NativeStackTrace.new = {}
__haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace"
__haxe_NativeStackTrace.saveStack = function(exception) end
__haxe_NativeStackTrace.callStack = function()
   local _g = debug.traceback()
   if _g == nil then
      do
         return _hx_tab_array({}, 0)
      end
   else
      do
         return String.prototype.split(_g, "\n"):slice(3)
      end
   end
end
__haxe_NativeStackTrace.exceptionStack = function()
   do
      return _hx_tab_array({}, 0)
   end
end

__haxe_Timer.new = function(time_ms)
   local self = _hx_new(__haxe_Timer.prototype)
   __haxe_Timer.super(self, time_ms)
   return self
end
__haxe_Timer.super = function(self, time_ms)
   local _gthis = self
   local dt = time_ms / 1000
   self.event = __haxe_MainLoop.add(function()
      local fh = _gthis.event
      fh.nextRun = fh.nextRun + dt
      _gthis:run()
   end)
   self.event:delay(dt)
end
__haxe_Timer.__name__ = "haxe.Timer"
__haxe_Timer.prototype = _hx_e()
__haxe_Timer.prototype.stop = function(self)
   if self.event ~= nil then
      self.event:stop()
      self.event = nil
   end
end
__haxe_Timer.prototype.run = function(self) end

__haxe_Timer.prototype.__class__ = __haxe_Timer

__haxe_ValueException.new = function(value, previous, native)
   local self = _hx_new(__haxe_ValueException.prototype)
   __haxe_ValueException.super(self, value, previous, native)
   return self
end
__haxe_ValueException.super = function(self, value, previous, native)
   __haxe_Exception.super(
      self,
      (function()
         local _hx_1
         if value == nil then
            _hx_1 = "null"
         else
            _hx_1 = Std.string(value)
         end
         return _hx_1
      end)(),
      previous,
      native
   )
   self.value = value
end
__haxe_ValueException.__name__ = "haxe.ValueException"
__haxe_ValueException.prototype = _hx_e()

__haxe_ValueException.prototype.__class__ = __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype, { __index = __haxe_Exception.prototype })

__haxe_ds_List.new = function()
   local self = _hx_new(__haxe_ds_List.prototype)
   __haxe_ds_List.super(self)
   return self
end
__haxe_ds_List.super = function(self)
   self.length = 0
end
__haxe_ds_List.__name__ = "haxe.ds.List"
__haxe_ds_List.prototype = _hx_e()
__haxe_ds_List.prototype.iterator = function(self)
   do
      return __haxe_ds__List_ListIterator.new(self.h)
   end
end

__haxe_ds_List.prototype.__class__ = __haxe_ds_List

__haxe_ds__List_ListNode.new = function(item, next)
   local self = _hx_new(__haxe_ds__List_ListNode.prototype)
   __haxe_ds__List_ListNode.super(self, item, next)
   return self
end
__haxe_ds__List_ListNode.super = function(self, item, next)
   self.item = item
   self.next = next
end
__haxe_ds__List_ListNode.__name__ = "haxe.ds._List.ListNode"
__haxe_ds__List_ListNode.prototype = _hx_e()

__haxe_ds__List_ListNode.prototype.__class__ = __haxe_ds__List_ListNode

__haxe_ds__List_ListIterator.new = function(head)
   local self = _hx_new(__haxe_ds__List_ListIterator.prototype)
   __haxe_ds__List_ListIterator.super(self, head)
   return self
end
__haxe_ds__List_ListIterator.super = function(self, head)
   self.head = head
end
__haxe_ds__List_ListIterator.__name__ = "haxe.ds._List.ListIterator"
__haxe_ds__List_ListIterator.prototype = _hx_e()
__haxe_ds__List_ListIterator.prototype.hasNext = function(self)
   do
      return self.head ~= nil
   end
end
__haxe_ds__List_ListIterator.prototype.next = function(self)
   local val = self.head.item
   self.head = self.head.next
   do
      return val
   end
end

__haxe_ds__List_ListIterator.prototype.__class__ = __haxe_ds__List_ListIterator

__haxe_ds_StringMap.new = function()
   local self = _hx_new(__haxe_ds_StringMap.prototype)
   __haxe_ds_StringMap.super(self)
   return self
end
__haxe_ds_StringMap.super = function(self)
   self.h = {}
end
__haxe_ds_StringMap.__name__ = "haxe.ds.StringMap"
__haxe_ds_StringMap.__interfaces__ = { __haxe_IMap }
__haxe_ds_StringMap.prototype = _hx_e()

__haxe_ds_StringMap.prototype.__class__ = __haxe_ds_StringMap

__haxe_exceptions_PosException.new = function(message, previous, pos)
   local self = _hx_new(__haxe_exceptions_PosException.prototype)
   __haxe_exceptions_PosException.super(self, message, previous, pos)
   return self
end
__haxe_exceptions_PosException.super = function(self, message, previous, pos)
   __haxe_Exception.super(self, message, previous)
   if pos == nil then
      self.posInfos = _hx_o({
         __fields__ = { fileName = true, lineNumber = true, className = true, methodName = true },
         fileName = "(unknown)",
         lineNumber = 0,
         className = "(unknown)",
         methodName = "(unknown)",
      })
   else
      self.posInfos = pos
   end
end
__haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException"
__haxe_exceptions_PosException.prototype = _hx_e()
__haxe_exceptions_PosException.prototype.toString = function(self)
   do
      return Std.string(
         Std.string(
            Std.string(
               Std.string(
                  Std.string(
                     Std.string(
                        Std.string(
                           Std.string(
                              Std.string("")
                                 .. Std.string(__haxe_Exception.prototype.toString(self))
                           ) .. Std.string(" in ")
                        ) .. Std.string(self.posInfos.className)
                     ) .. Std.string(".")
                  ) .. Std.string(self.posInfos.methodName)
               ) .. Std.string(" at ")
            ) .. Std.string(self.posInfos.fileName)
         ) .. Std.string(":")
      ) .. Std.string(self.posInfos.lineNumber)
   end
end

__haxe_exceptions_PosException.prototype.__class__ = __haxe_exceptions_PosException
__haxe_exceptions_PosException.__super__ = __haxe_Exception
setmetatable(__haxe_exceptions_PosException.prototype, { __index = __haxe_Exception.prototype })

__haxe_exceptions_NotImplementedException.new = function(message, previous, pos)
   local self = _hx_new(__haxe_exceptions_NotImplementedException.prototype)
   __haxe_exceptions_NotImplementedException.super(self, message, previous, pos)
   return self
end
__haxe_exceptions_NotImplementedException.super = function(self, message, previous, pos)
   if message == nil then
      message = "Not implemented"
   end
   __haxe_exceptions_PosException.super(self, message, previous, pos)
end
__haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException"
__haxe_exceptions_NotImplementedException.prototype = _hx_e()

__haxe_exceptions_NotImplementedException.prototype.__class__ =
   __haxe_exceptions_NotImplementedException
__haxe_exceptions_NotImplementedException.__super__ = __haxe_exceptions_PosException
setmetatable(
   __haxe_exceptions_NotImplementedException.prototype,
   { __index = __haxe_exceptions_PosException.prototype }
)

__haxe_iterators_ArrayIterator.new = function(array)
   local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
   __haxe_iterators_ArrayIterator.super(self, array)
   return self
end
__haxe_iterators_ArrayIterator.super = function(self, array)
   self.current = 0
   self.array = array
end
__haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator"
__haxe_iterators_ArrayIterator.prototype = _hx_e()
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self)
   do
      return self.current < self.array.length
   end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self)
   do
      return self.array[(function()
         local _hx_obj = self
         local _hx_fld = "current"
         local _ = _hx_obj[_hx_fld]
         _hx_obj[_hx_fld] = _hx_obj[_hx_fld] + 1
         return _
      end)()]
   end
end

__haxe_iterators_ArrayIterator.prototype.__class__ = __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array)
   local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
   __haxe_iterators_ArrayKeyValueIterator.super(self, array)
   return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self, array)
   self.current = 0
   self.array = array
end
__haxe_iterators_ArrayKeyValueIterator.__name__ = "haxe.iterators.ArrayKeyValueIterator"
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e()
__haxe_iterators_ArrayKeyValueIterator.prototype.hasNext = function(self)
   do
      return self.current < self.array.length
   end
end
__haxe_iterators_ArrayKeyValueIterator.prototype.next = function(self)
   do
      return _hx_o({
         __fields__ = { value = true, key = true },
         value = self.array[self.current],
         key = (function()
            local _hx_obj = self
            local _hx_fld = "current"
            local _ = _hx_obj[_hx_fld]
            _hx_obj[_hx_fld] = _hx_obj[_hx_fld] + 1
            return _
         end)(),
      })
   end
end

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ = __haxe_iterators_ArrayKeyValueIterator

__haxe_macro_Error.new = function(message, pos, previous)
   local self = _hx_new(__haxe_macro_Error.prototype)
   __haxe_macro_Error.super(self, message, pos, previous)
   return self
end
__haxe_macro_Error.super = function(self, message, pos, previous)
   __haxe_Exception.super(self, message, previous)
   self.pos = pos
end
__haxe_macro_Error.__name__ = "haxe.macro.Error"
__haxe_macro_Error.prototype = _hx_e()

__haxe_macro_Error.prototype.__class__ = __haxe_macro_Error
__haxe_macro_Error.__super__ = __haxe_Exception
setmetatable(__haxe_macro_Error.prototype, { __index = __haxe_Exception.prototype })

__lua_Boot.new = {}
__lua_Boot.__name__ = "lua.Boot"
__lua_Boot.__instanceof = function(o, cl)
   if cl == nil then
      do
         return false
      end
   end
   local cl1 = cl
   if cl1 == Array then
      do
         return __lua_Boot.isArray(o)
      end
   elseif cl1 == Bool then
      do
         return _G.type(o) == "boolean"
      end
   elseif cl1 == Dynamic then
      do
         return o ~= nil
      end
   elseif cl1 == Float then
      do
         return _G.type(o) == "number"
      end
   elseif cl1 == Int then
      if _G.type(o) == "number" then
         do
            return _hx_bit_clamp(o) == o
         end
      else
         do
            return false
         end
      end
   elseif cl1 == String then
      do
         return _G.type(o) == "string"
      end
   elseif cl1 == _G.table then
      do
         return _G.type(o) == "table"
      end
   elseif cl1 == __lua_Thread then
      do
         return _G.type(o) == "thread"
      end
   elseif cl1 == __lua_UserData then
      do
         return _G.type(o) == "userdata"
      end
   else
      if ((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table") then
         local tmp
         if __lua_Boot.__instanceof(o, Array) then
            tmp = Array
         else
            if __lua_Boot.__instanceof(o, String) then
               tmp = String
            else
               local cl = o.__class__
               tmp = (function()
                  local _hx_1
                  if cl ~= nil then
                     _hx_1 = cl
                  else
                     _hx_1 = nil
                  end
                  return _hx_1
               end)()
            end
         end
         if __lua_Boot.extendsOrImplements(tmp, cl) then
            do
               return true
            end
         end
         if
            (function()
               local _hx_2
               if cl == Class then
                  _hx_2 = o.__name__ ~= nil
               else
                  _hx_2 = false
               end
               return _hx_2
            end)()
         then
            do
               return true
            end
         end
         if
            (function()
               local _hx_3
               if cl == Enum then
                  _hx_3 = o.__ename__ ~= nil
               else
                  _hx_3 = false
               end
               return _hx_3
            end)()
         then
            do
               return true
            end
         end
         do
            return o.__enum__ == cl
         end
      else
         do
            return false
         end
      end
   end
end
__lua_Boot.isArray = function(o)
   if _G.type(o) == "table" then
      if (o.__enum__ == nil) and (_G.getmetatable(o) ~= nil) then
         do
            return _G.getmetatable(o).__index == Array.prototype
         end
      else
         do
            return false
         end
      end
   else
      do
         return false
      end
   end
end
__lua_Boot.extendsOrImplements = function(cl1, cl2)
   while true do
      _hx_do_first_1 = false

      if (cl1 == nil) or (cl2 == nil) then
         do
            return false
         end
      else
         if cl1 == cl2 then
            do
               return true
            end
         else
            if cl1.__interfaces__ ~= nil then
               local intf = cl1.__interfaces__
               local _g = 1
               local _g1 = _hx_table.maxn(intf) + 1
               while _g < _g1 do
                  _hx_do_first_2 = false

                  _g = _g + 1
                  local i = _g - 1
                  if __lua_Boot.extendsOrImplements(intf[i], cl2) then
                     do
                        return true
                     end
                  end
               end
            end
         end
      end
      cl1 = cl1.__super__
   end
end

__lua_UserData.new = {}
__lua_UserData.__name__ = "lua.UserData"

__lua_Thread.new = {}
__lua_Thread.__name__ = "lua.Thread"
if _hx_bit_raw then
   _hx_bit_clamp = function(v)
      if v <= 2147483647 and v >= -2147483648 then
         if v > 0 then
            return _G.math.floor(v)
         else
            return _G.math.ceil(v)
         end
      end
      if v > 2251798999999999 then
         v = v * 2
      end
      if v ~= v or math.abs(v) == _G.math.huge then
         return nil
      end
      return _hx_bit_raw.band(v, 2147483647) - math.abs(_hx_bit_raw.band(v, 2147483648))
   end
else
   _hx_bit_clamp = function(v)
      if v < -2147483648 then
         return -2147483648
      elseif v > 2147483647 then
         return 2147483647
      elseif v > 0 then
         return _G.math.floor(v)
      else
         return _G.math.ceil(v)
      end
   end
end

_hx_array_mt.__index = Array.prototype

if package.loaded.luv then
   _hx_luv = _G.require("luv")
else
   _hx_luv = {
      run = function(mode)
         return false
      end,
      loop_alive = function()
         return false
      end,
   }
end
local _hx_static_init = function()
   String.__name__ = "String"
   Array.__name__ = "Array"
   __echoes_Echoes.componentStorage = _hx_tab_array({}, 0)

   __echoes_Echoes._activeEntities = _hx_tab_array({}, 0)

   __echoes_Echoes.activeEntityIndices = _hx_tab_array({}, 0)

   __echoes_Echoes._activeViews = _hx_tab_array({}, 0)

   __echoes_Echoes.activeSystems = (function()
      local _hx_1

      local activeSystems = __echoes_SystemList.new()

      activeSystems:__activate__()

      activeSystems.clock.maxTime = 1

      _hx_1 = activeSystems
      return _hx_1
   end)()

   __echoes_Echoes.lastUpdate = Sys.time()

   ComponentStorage_EchoesBenchmarkOptional.instance =
      ComponentStorage_EchoesBenchmarkOptional.new()

   ComponentStorage_EchoesBenchmarkPadding1.instance =
      ComponentStorage_EchoesBenchmarkPadding1.new()

   ComponentStorage_EchoesBenchmarkPadding2.instance =
      ComponentStorage_EchoesBenchmarkPadding2.new()

   ComponentStorage_EchoesBenchmarkPadding3.instance =
      ComponentStorage_EchoesBenchmarkPadding3.new()

   ComponentStorage_EchoesBenchmarkPosition.instance =
      ComponentStorage_EchoesBenchmarkPosition.new()

   ComponentStorage_EchoesBenchmarkVelocity.instance =
      ComponentStorage_EchoesBenchmarkVelocity.new()

   ViewOf_Position_Velocity_92d16.instance = ViewOf_Position_Velocity_92d16.new()

   __echoes__ComponentStorage_EntityComponents_Impl_.components = _hx_tab_array({}, 0)

   __echoes__Entity_Entity_Impl_.nextId = 0

   __echoes__Entity_Entity_Impl_.idPool = _hx_tab_array({}, 0)

   __haxe_EntryPoint.pending = Array.new()

   __haxe_EntryPoint.threadCount = 0

   __haxe_ds_StringMap.tnull = {}
end

_hx_bind = function(o, m)
   if m == nil then
      return nil
   end
   local f
   if o._hx__closures == nil then
      _G.rawset(o, "_hx__closures", {})
   else
      f = o._hx__closures[m]
   end
   if f == nil then
      f = function(...)
         return m(o, ...)
      end
      o._hx__closures[m] = f
   end
   return f
end

_hx_funcToField = function(f)
   if type(f) == "function" then
      return function(self, ...)
         return f(...)
      end
   else
      return f
   end
end

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
   return { ... }
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn
   or function(t)
      local maxn = 0
      for i in pairs(t) do
         maxn = type(i) == "number" and i > maxn and i or maxn
      end
      return maxn
   end

function _hx_handle_error(obj)
   local message = tostring(obj)
   if _G.debug and _G.debug.traceback then
      -- level 2 to skip _hx_handle_error
      message = _G.debug.traceback(message, 2)
   end
   return setmetatable({}, {
      __tostring = function()
         return message
      end,
   })
end

_hx_static_init()
